<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Skylight Dashboard</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --bg-card: #334155;
            --text-primary: #ffffff;
            --text-secondary: #94a3b8;
            --text-muted: #64748b;
            --border-color: #475569;
            --accent: #6366f1;
        }

        :root.light {
            --bg-primary: #f8fafc;
            --bg-secondary: #ffffff;
            --bg-card: #f1f5f9;
            --text-primary: #1e293b;
            --text-secondary: #475569;
            --text-muted: #94a3b8;
            --border-color: #e2e8f0;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            transition: background 0.5s ease, color 0.5s ease;
        }

        .theme-transition {
            transition: background-color 0.5s ease, border-color 0.5s ease, color 0.5s ease;
        }

        .theme-text {
            color: var(--text-primary);
        }

        .theme-text-muted {
            color: var(--text-secondary);
        }

        .sidebar-btn { transition: all 0.3s ease; }
        .view-btn { transition: all 0.3s ease; }
        .day-cell { transition: all 0.2s ease; }
        .todo-item { transition: all 0.3s ease; }
        .event-badge { transition: all 0.2s ease; }

        .controls-frame {
            width: 100%;
            height: 100%;
            border: none;
            background: transparent;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes spin {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .loading-spin { animation: spin 1s linear infinite; }

        @keyframes pulse-slow {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.8; }
        }

        .animate-pulse-slow { animation: pulse-slow 2s ease-in-out infinite; }

        /* Connection status indicator (small, non-intrusive) */
        @keyframes connection-pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }
        @keyframes connection-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        .connection-indicator {
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            background: rgba(239, 68, 68, 0.9);
            backdrop-filter: blur(8px);
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        .connection-indicator.connecting {
            background: rgba(245, 158, 11, 0.9);
        }
        .connection-indicator .icon {
            width: 20px;
            height: 20px;
            animation: connection-blink 1s ease-in-out infinite;
        }
        .connection-indicator .text {
            color: white;
            font-size: 0.75rem;
            font-weight: 500;
        }
        .connection-indicator .dots {
            display: flex;
            gap: 2px;
        }
        .connection-indicator .dots span {
            width: 4px;
            height: 4px;
            background: white;
            border-radius: 50%;
            animation: connection-pulse 1.4s ease-in-out infinite;
        }
        .connection-indicator .dots span:nth-child(2) { animation-delay: 0.2s; }
        .connection-indicator .dots span:nth-child(3) { animation-delay: 0.4s; }

        /* Mail/Notifications Panel */
        .notifications-panel {
            position: fixed;
            left: 5.5rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 100;
            width: 320px;
            max-height: 70vh;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 1rem;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        .notifications-header {
            padding: 1rem;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .notifications-header h3 {
            font-size: 1rem;
            font-weight: 600;
            color: var(--text-primary);
        }
        .notifications-close {
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.5rem;
            background: rgba(100, 100, 100, 0.3);
            border: 1px solid rgba(150, 150, 150, 0.3);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.2s;
        }
        .notifications-close:hover {
            background: rgba(239, 68, 68, 0.3);
            border-color: rgba(239, 68, 68, 0.5);
            color: #ef4444;
        }
        .notifications-list {
            max-height: calc(70vh - 60px);
            overflow-y: auto;
            padding: 0.5rem;
        }
        .notification-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            border-radius: 0.5rem;
            background: var(--bg-card);
            margin-bottom: 0.5rem;
            position: relative;
            transition: all 0.2s;
        }
        .notification-item:hover {
            background: var(--bg-primary);
        }
        .notification-item:hover .notification-dismiss {
            opacity: 1;
        }
        .notification-icon {
            font-size: 1.5rem;
            flex-shrink: 0;
        }
        .notification-content {
            flex: 1;
            min-width: 0;
        }
        .notification-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: var(--text-primary);
        }
        .notification-count {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }
        .notification-dismiss {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.2);
            border: none;
            color: #ef4444;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 0.75rem;
        }
        .notification-dismiss:hover {
            background: rgba(239, 68, 68, 0.4);
        }
        .notifications-empty {
            padding: 2rem;
            text-align: center;
            color: var(--text-muted);
        }
        .mail-badge {
            position: absolute;
            top: 0.25rem;
            right: 0.25rem;
            min-width: 18px;
            height: 18px;
            background: #ef4444;
            color: white;
            font-size: 0.65rem;
            font-weight: 600;
            border-radius: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0 4px;
        }

        /* Screensaver Ken Burns animations */
        @keyframes kenburns-zoom-in {
            0% { transform: scale(1) translate(0, 0); }
            100% { transform: scale(1.2) translate(-2%, -2%); }
        }
        @keyframes kenburns-zoom-out {
            0% { transform: scale(1.2) translate(-2%, -2%); }
            100% { transform: scale(1) translate(0, 0); }
        }
        @keyframes kenburns-pan-left {
            0% { transform: scale(1.1) translate(3%, 0); }
            100% { transform: scale(1.1) translate(-3%, 0); }
        }
        @keyframes kenburns-pan-right {
            0% { transform: scale(1.1) translate(-3%, 0); }
            100% { transform: scale(1.1) translate(3%, 0); }
        }

        .kenburns-zoom-in { animation: kenburns-zoom-in 15s ease-out forwards; }
        .kenburns-zoom-out { animation: kenburns-zoom-out 15s ease-out forwards; }
        .kenburns-pan-left { animation: kenburns-pan-left 15s ease-out forwards; }
        .kenburns-pan-right { animation: kenburns-pan-right 15s ease-out forwards; }

        /* Screensaver styles */
        .screensaver-overlay {
            position: fixed;
            inset: 0;
            z-index: 35;
            background: black;
            overflow: hidden;
        }

        .screensaver-bg {
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            transition: opacity 1.5s ease-in-out;
        }

        .screensaver-active .main-header {
            position: fixed !important;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50 !important;
            padding: 1.5rem !important;
            pointer-events: none;
            transition: all 0.5s ease;
        }

        .screensaver-active .main-header * {
            pointer-events: auto;
        }

        /* Header overlay for dark backgrounds (light text) */
        .screensaver-active .main-header.overlay-light {
            background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7) 0%, rgba(0, 0, 0, 0.4) 60%, transparent 100%) !important;
        }

        .screensaver-active .main-header.overlay-light,
        .screensaver-active .main-header.overlay-light * {
            color: white !important;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9) !important;
        }

        .screensaver-active .main-header.overlay-light .theme-text-muted {
            color: rgba(255, 255, 255, 0.8) !important;
        }

        /* Header overlay for light backgrounds (dark text) */
        .screensaver-active .main-header.overlay-dark {
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.85) 0%, rgba(255, 255, 255, 0.6) 60%, transparent 100%) !important;
        }

        .screensaver-active .main-header.overlay-dark,
        .screensaver-active .main-header.overlay-dark * {
            color: #1e293b !important;
            text-shadow: 0 2px 8px rgba(255, 255, 255, 0.7) !important;
        }

        .screensaver-active .main-header.overlay-dark .theme-text-muted {
            color: rgba(30, 41, 59, 0.7) !important;
        }

        .screensaver-metadata {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            color: white;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.8);
            z-index: 5;
        }

        .screensaver-controls {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            z-index: 5;
        }

        #screensaver-mini-calendar {
            min-width: 320px;
            top: 50% !important;
            transform: translateY(-50%);
            transition: all 0.5s ease;
        }

        #screensaver-mini-calendar .cal-day {
            width: 40px;
            height: 40px;
            font-size: 1.1rem;
        }

        #screensaver-mini-calendar .cal-header {
            font-size: 0.9rem;
        }

        /* Light overlay theme (for dark backgrounds) */
        .overlay-light {
            color: white !important;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.9), 0 0 20px rgba(0, 0, 0, 0.7) !important;
            background: rgba(0, 0, 0, 0.2) !important;
            border-color: rgba(255, 255, 255, 0.15) !important;
        }

        .overlay-light .cal-today {
            background: white !important;
            color: #1e293b !important;
            font-weight: 700;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(255, 255, 255, 0.4);
        }

        .overlay-light .cal-day:not(.cal-today) {
            color: white !important;
        }

        /* Dark overlay theme (for light backgrounds) */
        .overlay-dark {
            color: #1e293b !important;
            text-shadow: 0 2px 10px rgba(255, 255, 255, 0.9), 0 0 20px rgba(255, 255, 255, 0.7) !important;
            background: rgba(255, 255, 255, 0.2) !important;
            border-color: rgba(0, 0, 0, 0.15) !important;
        }

        .overlay-dark .cal-today {
            background: #1e293b !important;
            color: white !important;
            font-weight: 700;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }

        .overlay-dark .cal-day:not(.cal-today) {
            color: #1e293b !important;
        }

        .overlay-dark .cal-header,
        .overlay-dark #mini-cal-year {
            opacity: 0.7 !important;
        }

        /* Metadata overlay themes */
        .screensaver-metadata.overlay-light {
            color: white !important;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9) !important;
        }

        .screensaver-metadata.overlay-dark {
            color: #1e293b !important;
            text-shadow: 0 2px 8px rgba(255, 255, 255, 0.9) !important;
            background: rgba(255, 255, 255, 0.7) !important;
            padding: 8px 12px !important;
            border-radius: 8px !important;
        }

        .screensaver-loading {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.8);
        }

        .calendar-color-kids { background-color: #ec4899; }
        .calendar-color-personal { background-color: #6366f1; }
        .calendar-color-work { background-color: #f59e0b; }
        .calendar-color-family { background-color: #10b981; }

        /* Mail/Package Notification Overlay */
        #mail-notification {
            position: fixed;
            bottom: 2rem;
            left: 2rem;
            z-index: 40;
            transition: all 0.5s ease;
        }

        #mail-notification.overlay-light {
            color: white;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.9);
        }

        #mail-notification.overlay-light .mail-card {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        #mail-notification.overlay-dark {
            color: #1e293b;
            text-shadow: 0 2px 8px rgba(255, 255, 255, 0.7);
        }

        #mail-notification.overlay-dark .mail-card {
            background: rgba(255, 255, 255, 0.4);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .mail-card {
            backdrop-filter: blur(12px);
            border-radius: 16px;
            padding: 1rem 1.25rem;
        }

        .mail-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0;
        }

        .mail-item:not(:last-child) {
            border-bottom: 1px solid rgba(128, 128, 128, 0.2);
        }

        .mail-icon {
            font-size: 1.75rem;
        }

        .mail-count {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .mail-label {
            font-size: 0.875rem;
            opacity: 0.8;
        }

        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body class="bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 min-h-screen">

    <!-- Connection Status Indicator (small, top-left) -->
    <div id="connection-indicator" class="connection-indicator connecting hidden">
        <svg class="icon" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.111 16.404a5.5 5.5 0 017.778 0M12 20h.01m-7.08-7.071c3.904-3.905 10.236-3.905 14.14 0"/>
        </svg>
        <span class="text" id="connection-text">Connecting</span>
        <div class="dots">
            <span></span>
            <span></span>
            <span></span>
        </div>
    </div>

    <!-- Screensaver Overlay -->
    <div id="screensaverOverlay" class="screensaver-overlay hidden">
        <!-- Background layers for crossfade -->
        <div id="screensaver-bg-1" class="screensaver-bg opacity-100"></div>
        <div id="screensaver-bg-2" class="screensaver-bg opacity-0"></div>

        <!-- Loading spinner -->
        <div id="screensaver-loading" class="screensaver-loading hidden">
            <div class="flex flex-col items-center gap-4">
                <svg class="w-12 h-12 text-white loading-spin" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                </svg>
                <span class="text-white text-lg">Loading photos...</span>
            </div>
        </div>

        <!-- Photo metadata -->
        <div id="screensaver-metadata" class="screensaver-metadata hidden">
            <div id="screensaver-date" class="text-lg font-light opacity-80"></div>
            <div id="screensaver-location" class="text-sm opacity-60"></div>
        </div>

        <!-- Mini Calendar -->
        <div id="screensaver-mini-calendar" class="absolute right-8 backdrop-blur-lg rounded-2xl p-6 z-10 border overlay-light">
            <div id="mini-cal-header" class="text-center mb-4">
                <div id="mini-cal-month" class="text-3xl font-light tracking-wide"></div>
                <div id="mini-cal-year" class="text-lg opacity-80 mt-1"></div>
            </div>
            <div id="mini-cal-grid" class="grid grid-cols-7 gap-2 text-center">
                <!-- Day headers -->
                <div class="cal-header text-sm opacity-70 font-semibold pb-2">S</div>
                <div class="cal-header text-sm opacity-70 font-semibold pb-2">M</div>
                <div class="cal-header text-sm opacity-70 font-semibold pb-2">T</div>
                <div class="cal-header text-sm opacity-70 font-semibold pb-2">W</div>
                <div class="cal-header text-sm opacity-70 font-semibold pb-2">T</div>
                <div class="cal-header text-sm opacity-70 font-semibold pb-2">F</div>
                <div class="cal-header text-sm opacity-70 font-semibold pb-2">S</div>
                <!-- Days will be populated by JS -->
            </div>
        </div>

        <!-- Controls -->
        <div class="screensaver-controls flex items-center gap-3">
            <button onclick="screensaverController?.previousPhoto()" class="w-10 h-10 bg-white/20 hover:bg-white/30 backdrop-blur rounded-full flex items-center justify-center text-white transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
            </button>
            <button onclick="screensaverController?.nextPhoto()" class="w-10 h-10 bg-white/20 hover:bg-white/30 backdrop-blur rounded-full flex items-center justify-center text-white transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
            </button>
            <button onclick="openScreensaverSettings()" class="w-10 h-10 bg-white/20 hover:bg-white/30 backdrop-blur rounded-full flex items-center justify-center text-white transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
            </button>
        </div>
    </div>

    <!-- Mail/Package Notification Overlay -->
    <div id="mail-notification" class="hidden overlay-light">
        <div class="mail-card relative">
            <button onclick="hideMailNotification()" class="absolute -top-2 -right-2 w-8 h-8 flex items-center justify-center rounded-full bg-slate-700/80 hover:bg-red-500/80 text-white border border-slate-500/50 hover:border-red-400 transition-all shadow-lg" title="Close">
                <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M6 18L18 6M6 6l12 12"/></svg>
            </button>
            <div id="mail-items">
                <!-- Populated by JS -->
            </div>
        </div>
    </div>

    <!-- Camera Overlay (for doorbell/security cameras) -->
    <div id="cameraOverlay" class="fixed inset-0 bg-black/95 z-[70] hidden flex items-center justify-center">
        <!-- Camera title -->
        <div id="camera-title" class="absolute top-6 left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur px-6 py-3 rounded-full">
            <span class="text-white text-lg font-medium">Front Door</span>
        </div>

        <!-- Camera stream container -->
        <div id="camera-container" class="relative w-full h-full flex items-center justify-center p-12">
            <!-- Loading spinner -->
            <div id="camera-loading" class="absolute inset-0 flex items-center justify-center">
                <div class="flex flex-col items-center gap-4">
                    <svg class="w-12 h-12 text-white animate-spin" fill="none" viewBox="0 0 24 24">
                        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4z"></path>
                    </svg>
                    <span class="text-white text-lg">Loading camera...</span>
                </div>
            </div>

            <!-- Camera image (for MJPEG stream or snapshots) -->
            <img id="camera-stream" class="max-w-full max-h-full object-contain hidden rounded-lg shadow-2xl" alt="Camera feed">

            <!-- Error message -->
            <div id="camera-error" class="hidden text-center">
                <svg class="w-16 h-16 text-red-400 mx-auto mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"/>
                </svg>
                <p class="text-white text-lg">Camera unavailable</p>
                <p class="text-slate-400 text-sm mt-2">Could not load camera stream</p>
            </div>
        </div>

        <!-- Countdown timer -->
        <div id="camera-countdown" class="absolute bottom-6 left-1/2 -translate-x-1/2 bg-black/60 backdrop-blur px-4 py-2 rounded-full">
            <span class="text-white text-sm">Closing in <span id="camera-seconds">30</span>s</span>
        </div>

        <!-- Close button -->
        <button onclick="cameraViewer.hide()" class="absolute top-6 right-6 w-12 h-12 bg-white/20 hover:bg-white/30 backdrop-blur rounded-full flex items-center justify-center text-white transition-colors">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
            </svg>
        </button>

        <!-- Fullscreen toggle -->
        <button onclick="cameraViewer.toggleFullscreen()" class="absolute top-6 right-24 w-12 h-12 bg-white/20 hover:bg-white/30 backdrop-blur rounded-full flex items-center justify-center text-white transition-colors">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"/>
            </svg>
        </button>
    </div>

    <!-- Screensaver Settings Modal -->
    <div id="screensaverSettingsModal" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-[60] hidden">
        <div class="bg-slate-800 p-6 w-full max-w-lg border border-slate-700 shadow-2xl max-h-[90vh] overflow-y-auto">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-semibold text-white">Screensaver Settings</h3>
                <button onclick="closeScreensaverSettings()" class="w-10 h-10 bg-slate-700/50 hover:bg-slate-600/50 flex items-center justify-center text-white">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
            </div>

            <div class="space-y-6">
                <!-- Enable Toggle -->
                <div class="flex items-center justify-between">
                    <div>
                        <div class="text-white font-medium">Enable Screensaver</div>
                        <div class="text-sm text-slate-400">Activate slideshow when idle</div>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="ss-enabled" class="sr-only peer" onchange="updateScreensaverSetting('enabled', this.checked)">
                        <div class="w-11 h-6 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                </div>

                <!-- Idle Timeout -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-white font-medium">Idle Timeout</span>
                        <span id="ss-idle-value" class="text-slate-400">5 minutes</span>
                    </div>
                    <input type="range" id="ss-idle-timeout" min="1" max="30" value="5"
                        class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                        oninput="document.getElementById('ss-idle-value').textContent = this.value + ' minute' + (this.value == 1 ? '' : 's')"
                        onchange="updateScreensaverSetting('idleTimeout', this.value * 60000)">
                </div>

                <!-- Slide Duration -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <span class="text-white font-medium">Photo Duration</span>
                        <span id="ss-slide-value" class="text-slate-400">10 seconds</span>
                    </div>
                    <input type="range" id="ss-slide-interval" min="5" max="60" value="10"
                        class="w-full h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500"
                        oninput="document.getElementById('ss-slide-value').textContent = this.value + ' seconds'"
                        onchange="updateScreensaverSetting('slideInterval', this.value * 1000)">
                </div>

                <!-- Ken Burns Toggle -->
                <div class="flex items-center justify-between">
                    <div>
                        <div class="text-white font-medium">Ken Burns Effect</div>
                        <div class="text-sm text-slate-400">Smooth pan and zoom animations</div>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="ss-kenburns" class="sr-only peer" onchange="updateScreensaverSetting('kenBurnsEnabled', this.checked)">
                        <div class="w-11 h-6 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                </div>

                <!-- Show Metadata Toggle -->
                <div class="flex items-center justify-between">
                    <div>
                        <div class="text-white font-medium">Show Photo Info</div>
                        <div class="text-sm text-slate-400">Display date and location</div>
                    </div>
                    <label class="relative inline-flex items-center cursor-pointer">
                        <input type="checkbox" id="ss-metadata" class="sr-only peer" onchange="updateScreensaverSetting('showMetadata', this.checked)">
                        <div class="w-11 h-6 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                    </label>
                </div>

                <!-- Hourly Chime -->
                <div class="border-t border-slate-700 pt-6">
                    <h4 class="text-white font-medium mb-4">Hourly Chime</h4>

                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <div class="text-white font-medium">Enable Hourly Chime</div>
                            <div class="text-sm text-slate-400">Play a chime sound every hour</div>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="ss-hourly-chime" class="sr-only peer" onchange="updateScreensaverSetting('hourlyChimeEnabled', this.checked)">
                            <div class="w-11 h-6 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                    </div>

                    <div class="flex items-center justify-between mb-4">
                        <div>
                            <div class="text-white font-medium">Announce Time</div>
                            <div class="text-sm text-slate-400">Speak the time aloud</div>
                        </div>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="ss-hourly-callout" class="sr-only peer" onchange="updateScreensaverSetting('hourlyChimeCallout', this.checked)">
                            <div class="w-11 h-6 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-indigo-600"></div>
                        </label>
                    </div>

                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label class="block text-sm text-slate-400 mb-2">Start Hour</label>
                            <select id="ss-chime-start" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500" onchange="updateScreensaverSetting('hourlyChimeStart', parseInt(this.value))">
                                <option value="5">5:00 AM</option>
                                <option value="6">6:00 AM</option>
                                <option value="7">7:00 AM</option>
                                <option value="8">8:00 AM</option>
                                <option value="9">9:00 AM</option>
                            </select>
                        </div>
                        <div>
                            <label class="block text-sm text-slate-400 mb-2">End Hour</label>
                            <select id="ss-chime-end" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500" onchange="updateScreensaverSetting('hourlyChimeEnd', parseInt(this.value))">
                                <option value="20">8:00 PM</option>
                                <option value="21">9:00 PM</option>
                                <option value="22">10:00 PM</option>
                                <option value="23">11:00 PM</option>
                            </select>
                        </div>
                    </div>

                    <button onclick="testHourlyChime()" class="mt-4 w-full py-2 bg-slate-700 hover:bg-slate-600 text-white font-medium transition-colors">
                        Test Chime
                    </button>
                </div>

                <!-- Photo Source -->
                <div class="border-t border-slate-700 pt-6">
                    <h4 class="text-white font-medium mb-4">Photo Source</h4>

                    <div class="mb-4">
                        <label class="block text-sm text-slate-400 mb-2">Provider</label>
                        <select id="ss-provider" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500" onchange="updateScreensaverSetting('providerType', this.value); toggleProviderConfig(this.value)">
                            <option value="local">Local/Network Folder</option>
                            <option value="synology">Synology Photos</option>
                            <option value="google" disabled>Google Photos (Coming Soon)</option>
                        </select>
                    </div>

                    <!-- Local Folder Config -->
                    <div id="local-config" class="space-y-4">
                        <div>
                            <label class="block text-sm text-slate-400 mb-2">Folder Path</label>
                            <input type="text" id="ss-local-path" placeholder="/path/to/photos or /mnt/nas/photos"
                                class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                onchange="updateLocalConfig()">
                            <p class="text-xs text-slate-500 mt-1">Absolute path to folder containing images (supports SMB mounts)</p>
                        </div>

                        <div class="flex gap-3">
                            <button onclick="testLocalConnection()" class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 text-white font-medium transition-colors">
                                Test Connection
                            </button>
                            <button onclick="previewScreensaver()" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-medium transition-colors">
                                Preview
                            </button>
                        </div>

                        <div id="ss-local-status" class="text-sm hidden"></div>
                    </div>

                    <!-- Synology Config -->
                    <div id="synology-config" class="space-y-4 hidden">
                        <div>
                            <label class="block text-sm text-slate-400 mb-2">Share Link</label>
                            <input type="text" id="ss-synology-share" placeholder="http://your-nas:5000/mo/sharing/xxxxx"
                                class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white placeholder-slate-500 focus:outline-none focus:ring-2 focus:ring-indigo-500"
                                onchange="updateSynologyConfig()">
                            <p class="text-xs text-slate-500 mt-1">Paste the full shared album URL from Synology Photos</p>
                        </div>

                        <div class="flex gap-3">
                            <button onclick="testSynologyConnection()" class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 text-white font-medium transition-colors">
                                Test Connection
                            </button>
                            <button onclick="previewScreensaver()" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-medium transition-colors">
                                Preview
                            </button>
                        </div>

                        <div id="ss-connection-status" class="text-sm hidden"></div>
                    </div>
                </div>

                <!-- MQTT Integration -->
                <div class="border-t border-slate-700 pt-6">
                    <h4 class="text-white font-medium mb-4">Home Assistant Integration</h4>

                    <!-- Connection Status -->
                    <div class="bg-slate-900/50 rounded-lg p-4 mb-4">
                        <div class="flex items-center justify-between mb-3">
                            <span class="text-slate-400">WebSocket Bridge</span>
                            <span id="mqtt-ws-status" class="flex items-center gap-2">
                                <span class="w-2 h-2 rounded-full bg-slate-500"></span>
                                <span class="text-slate-400 text-sm">Checking...</span>
                            </span>
                        </div>
                        <div class="flex items-center justify-between">
                            <span class="text-slate-400">MQTT Broker</span>
                            <span id="mqtt-broker-status" class="flex items-center gap-2">
                                <span class="w-2 h-2 rounded-full bg-slate-500"></span>
                                <span class="text-slate-400 text-sm">Unknown</span>
                            </span>
                        </div>
                    </div>

                    <p class="text-xs text-slate-500 mb-4">
                        MQTT allows Home Assistant to send commands to this dashboard (wake on motion, doorbell camera, TTS announcements).
                        Configure MQTT in <code class="bg-slate-700 px-1 rounded">config.py</code> on the server.
                    </p>

                    <!-- Test Commands -->
                    <div class="space-y-3">
                        <div class="text-sm text-slate-400 mb-2">Test Commands</div>

                        <div class="grid grid-cols-2 gap-3">
                            <button onclick="testMQTTCommand('wake')" class="py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium transition-colors rounded">
                                Wake Screen
                            </button>
                            <button onclick="testMQTTCommand('screensaver')" class="py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium transition-colors rounded">
                                Start Screensaver
                            </button>
                            <button onclick="testMQTTCommand('speak')" class="py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium transition-colors rounded">
                                Test TTS
                            </button>
                            <button onclick="testMQTTCommand('doorbell')" class="py-2 bg-slate-700 hover:bg-slate-600 text-white text-sm font-medium transition-colors rounded">
                                Test Doorbell
                            </button>
                        </div>

                        <div id="mqtt-test-status" class="text-sm text-center hidden py-2 rounded"></div>
                    </div>

                    <!-- MQTT Topics Reference -->
                    <details class="mt-4">
                        <summary class="text-sm text-slate-400 cursor-pointer hover:text-slate-300">MQTT Topic Reference</summary>
                        <div class="mt-3 bg-slate-900/50 rounded-lg p-3 text-xs font-mono space-y-2">
                            <div>
                                <span class="text-slate-500">Command:</span>
                                <span class="text-emerald-400">skylight/{device_id}/command</span>
                            </div>
                            <div>
                                <span class="text-slate-500">State:</span>
                                <span class="text-blue-400">skylight/{device_id}/state</span>
                            </div>
                            <div>
                                <span class="text-slate-500">Availability:</span>
                                <span class="text-amber-400">skylight/{device_id}/availability</span>
                            </div>
                            <div class="pt-2 border-t border-slate-700 mt-2">
                                <div class="text-slate-400 mb-2">Example Commands:</div>
                                <code class="block text-slate-300 whitespace-pre-wrap">{"command": "wake"}
{"command": "speak", "message": "Hello!", "alarm": true}
{"command": "show_camera", "entity_id": "camera.doorbell", "title": "Front Door"}</code>
                            </div>
                        </div>
                    </details>
                </div>

                <!-- Version -->
                <div class="border-t border-slate-700 pt-4 mt-6 text-center">
                    <span id="dashboard-version" class="text-slate-500 text-sm">Skylight Dashboard</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Event Alert Modal -->
    <div id="alertModal" class="fixed inset-0 bg-black/70 backdrop-blur-sm flex items-center justify-center z-[100] hidden">
        <div class="bg-gradient-to-br from-indigo-600 to-purple-700 p-1 rounded-lg shadow-2xl max-w-md w-full mx-4 animate-pulse-slow">
            <div class="bg-slate-900 rounded-lg p-6">
                <div class="flex items-center gap-3 mb-4">
                    <div class="w-12 h-12 bg-indigo-500 rounded-full flex items-center justify-center text-2xl animate-bounce">
                        üîî
                    </div>
                    <div>
                        <div class="text-indigo-400 text-sm font-medium">Upcoming Event</div>
                        <div id="alert-time" class="text-slate-400 text-xs">Starting soon</div>
                    </div>
                </div>

                <h3 id="alert-title" class="text-2xl font-bold text-white mb-2">Event Title</h3>
                <p id="alert-details" class="text-slate-400 mb-4">Event details will appear here</p>

                <!-- Volume Control -->
                <div class="flex items-center gap-3 mb-4 p-3 bg-slate-800 rounded-lg">
                    <span class="text-slate-400 text-sm">üîà</span>
                    <input type="range" id="alarm-volume" min="0" max="100" value="70"
                        onchange="setAlarmVolume(this.value)"
                        class="flex-1 h-2 bg-slate-700 rounded-lg appearance-none cursor-pointer accent-indigo-500">
                    <span class="text-slate-400 text-sm">üîä</span>
                    <span id="volume-display" class="text-white text-sm font-medium w-10 text-right">70%</span>
                </div>

                <div class="flex gap-3">
                    <button onclick="snoozeAlert(5)" class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 text-white font-medium rounded-lg transition-colors">
                        ‚è∞ Snooze 5m
                    </button>
                    <button onclick="snoozeAlert(15)" class="flex-1 py-3 bg-slate-700 hover:bg-slate-600 text-white font-medium rounded-lg transition-colors">
                        ‚è∞ Snooze 15m
                    </button>
                    <button onclick="dismissAlert()" class="flex-1 py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-medium rounded-lg transition-colors">
                        ‚úì Done
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Prayer Time Notification (gentle, no alarm) -->
    <div id="prayerNotification" class="fixed inset-0 bg-black/60 backdrop-blur-sm flex items-center justify-center z-[90] hidden">
        <div class="text-center animate-fade-in">
            <div class="text-8xl mb-6">üïå</div>
            <div id="prayer-notification-text" class="text-4xl font-light text-white mb-2">Get ready, time for Fajr</div>
            <div id="prayer-notification-time" class="text-xl text-white/70"></div>
            <button onclick="closePrayerNotification()" class="mt-8 px-8 py-3 bg-white/20 hover:bg-white/30 text-white font-medium rounded-full transition-colors">
                Dismiss
            </button>
        </div>
    </div>

    <!-- Event Modal --><div id="eventModal" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 hidden">
        <div class="bg-slate-800 p-6 w-full max-w-md border border-slate-700 shadow-2xl">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-semibold text-white">New Event</h3>
                <button onclick="closeEventModal()" class="w-10 h-10 bg-slate-700/50 hover:bg-slate-600/50 flex items-center justify-center text-white">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium text-slate-400 mb-2">Event Title</label>
                    <input type="text" id="eventTitle" placeholder="Enter event title..." class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-400 mb-2">Calendar</label>
                    <select id="eventCalendar" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                        <!-- Populated dynamically -->
                    </select>
                </div>
                <div>
                    <label class="block text-sm font-medium text-slate-400 mb-2">Date</label>
                    <input type="date" id="eventDate" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium text-slate-400 mb-2">Start Time</label>
                        <input type="time" id="eventStartTime" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-slate-400 mb-2">End Time</label>
                        <input type="time" id="eventEndTime" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                    </div>
                </div>

                <!-- Recurring Event Options -->
                <div class="border-t border-slate-600 pt-4">
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" id="eventRecurring" onchange="toggleRecurringOptions()" class="w-5 h-5 bg-slate-700 border-slate-600 text-indigo-600 focus:ring-indigo-500 focus:ring-2">
                        <span class="text-sm font-medium text-slate-400">Repeat this event</span>
                    </label>

                    <div id="recurringOptions" class="hidden mt-4 space-y-4">
                        <div>
                            <label class="block text-sm font-medium text-slate-400 mb-2">Repeat</label>
                            <select id="eventRecurrenceType" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                <option value="daily">Daily</option>
                                <option value="weekly" selected>Weekly</option>
                                <option value="biweekly">Every 2 Weeks</option>
                                <option value="monthly">Monthly</option>
                            </select>
                        </div>

                        <div>
                            <label class="block text-sm font-medium text-slate-400 mb-2">End After</label>
                            <div class="grid grid-cols-2 gap-4">
                                <div>
                                    <select id="eventRecurrenceEndType" onchange="toggleRecurrenceEndType()" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                        <option value="occurrences" selected>Occurrences</option>
                                        <option value="date">End Date</option>
                                    </select>
                                </div>
                                <div id="recurrenceOccurrencesDiv">
                                    <input type="number" id="eventRecurrenceOccurrences" value="10" min="1" max="365" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                </div>
                                <div id="recurrenceEndDateDiv" class="hidden col-span-2">
                                    <input type="date" id="eventRecurrenceEndDate" class="w-full px-4 py-3 bg-slate-700 border border-slate-600 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <button id="createEventBtn" onclick="submitNewEvent()" class="w-full py-3 bg-indigo-600 hover:bg-indigo-700 text-white font-medium">
                    Create Event
                </button>
            </div>
        </div>
    </div>

    <!-- Event Details Modal -->
    <div id="eventDetailsModal" class="fixed inset-0 bg-black/50 backdrop-blur-sm flex items-center justify-center z-50 hidden">
        <div class="bg-slate-800 p-6 w-full max-w-md border border-slate-700 shadow-2xl">
            <div class="flex justify-between items-center mb-6">
                <h3 class="text-xl font-semibold text-white">Event Details</h3>
                <button onclick="closeEventDetailsModal()" class="w-10 h-10 bg-slate-700/50 hover:bg-slate-600/50 flex items-center justify-center text-white">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
            </div>
            <div id="eventDetailsContent" class="space-y-4">
                <!-- Content will be populated dynamically -->
            </div>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="flex flex-col h-screen overflow-hidden">
        <!-- Full-Width Header -->
        <div id="main-header" class="main-header flex justify-between items-center px-6 pt-6 pb-4 flex-shrink-0">
            <div class="flex items-center gap-8">
                <!-- Weather -->
                <div class="flex items-center gap-3">
                    <div id="weather-icon" class="text-5xl">üå°Ô∏è</div>
                    <div>
                        <div class="flex items-baseline gap-2">
                            <span id="weather-temp" class="text-3xl font-light theme-text">--¬∞</span>
                            <span id="weather-condition" class="text-sm theme-text-muted">Loading...</span>
                        </div>
                        <div class="flex items-center gap-3 text-xs theme-text-muted mt-1">
                            <span id="weather-hilo">H: --¬∞ L: --¬∞</span>
                            <span id="weather-extra"></span>
                        </div>
                    </div>
                </div>

                <!-- Sunrise/Sunset -->
                <div class="flex items-center gap-4 pl-6 border-l border-slate-700/50">
                    <div class="flex items-center gap-2">
                        <span class="text-lg">üåÖ</span>
                        <div>
                            <div class="text-[10px] theme-text-muted uppercase">Sunrise</div>
                            <div id="sunrise-time" class="text-sm font-medium theme-text">--:--</div>
                        </div>
                    </div>
                    <div class="flex items-center gap-2">
                        <span class="text-lg">üåá</span>
                        <div>
                            <div class="text-[10px] theme-text-muted uppercase">Sunset</div>
                            <div id="sunset-time" class="text-sm font-medium theme-text">--:--</div>
                        </div>
                    </div>
                </div>

                <!-- Prayer Times -->
                <div class="flex items-center gap-3 pl-6 border-l border-slate-700/50">
                    <div class="flex items-center gap-2">
                        <span class="text-lg">üïå</span>
                        <div>
                            <div class="text-[10px] theme-text-muted uppercase">Next Prayer</div>
                            <div class="flex items-baseline gap-2">
                                <span id="next-prayer-name" class="text-sm font-medium theme-text">--</span>
                                <span id="next-prayer-time" class="text-xs theme-text-muted">--:--</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Time -->
            <div class="text-right">
                <div id="current-time" class="text-5xl font-light theme-text tracking-tight">--:--</div>
                <div id="current-date" class="theme-text-muted text-sm mt-1">Loading...</div>
            </div>
        </div>

        <!-- Content Area with Sidebar -->
        <div class="flex flex-1 overflow-hidden">
        <!-- Left Sidebar -->
        <div id="sidebar" class="w-20 bg-slate-900/50 backdrop-blur-xl border-r border-slate-700/50 flex flex-col items-center py-4 gap-2 theme-transition">
            <div class="w-12 h-12 bg-indigo-600 flex items-center justify-center mb-8">
                <span class="text-white font-bold text-xl">S</span>
            </div>

            <button onclick="setActiveTab('calendar')" id="btn-calendar" class="sidebar-btn w-14 h-14 flex items-center justify-center bg-indigo-600 text-white">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
            </button>

            <button onclick="setActiveTab('todos')" id="btn-todos" class="sidebar-btn w-14 h-14 flex items-center justify-center bg-slate-800/50 hover:bg-slate-700/50 text-slate-400 hover:text-white">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/></svg>
            </button>

            <button onclick="setActiveTab('controls')" id="btn-controls" class="sidebar-btn w-14 h-14 flex items-center justify-center bg-slate-800/50 hover:bg-slate-700/50 text-slate-400 hover:text-white" title="Home Assistant Controls">
                <svg class="w-6 h-6" viewBox="0 0 24 24" fill="currentColor"><path d="M21.8,13H20V21H4V13H2.2C1.76,13 1.44,12.5 1.68,12.13L11.5,1.54C11.72,1.28 12.28,1.28 12.5,1.54L22.32,12.13C22.56,12.5 22.24,13 21.8,13M7,10V12H9V10H7M11,10V12H13V10H11M15,10V12H17V10H15M7,14V16H9V14H7M11,14V16H13V14H11M15,14V16H17V14H15M7,18V20H9V18H7M11,18V20H13V18H11M15,18V20H17V18H15Z"/></svg>
            </button>

            <button onclick="toggleNotificationsPanel()" id="btn-mail" class="sidebar-btn w-14 h-14 flex items-center justify-center bg-slate-800/50 hover:bg-slate-700/50 text-slate-400 hover:text-white relative" title="Mail & Packages">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 8l7.89 5.26a2 2 0 002.22 0L21 8M5 19h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"/></svg>
                <span id="mail-badge" class="mail-badge hidden">0</span>
            </button>

            <div class="flex-1"></div>

            <button onclick="refreshData()" id="refresh-btn" class="sidebar-btn w-14 h-14 flex items-center justify-center bg-slate-800/50 hover:bg-slate-700/50 text-slate-400 hover:text-white">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></svg>
            </button>

            <button onclick="toggleTheme()" id="theme-btn" class="sidebar-btn w-14 h-14 flex items-center justify-center bg-slate-800/50 hover:bg-slate-700/50 text-2xl" title="Toggle theme">
                <span id="theme-icon">‚òÄÔ∏è</span>
            </button>

            <button onclick="openScreensaverSettings()" id="screensaver-btn" class="sidebar-btn w-14 h-14 flex items-center justify-center bg-slate-800/50 hover:bg-slate-700/50 text-slate-400 hover:text-white" title="Screensaver Settings">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
            </button>
        </div>

        <!-- Notifications Panel -->
        <div id="notifications-panel" class="notifications-panel hidden">
            <div class="notifications-header">
                <h3>üîî Notifications</h3>
                <button class="notifications-close" onclick="closeNotificationsPanel()" title="Close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" d="M6 18L18 6M6 6l12 12"/></svg>
                </button>
            </div>
            <div id="notifications-list" class="notifications-list">
                <div class="notifications-empty">üì≠ No notifications</div>
            </div>
        </div>

        <!-- Main Content -->
        <div class="flex-1 flex flex-col p-6 pt-2 h-full overflow-hidden">
            <!-- Tab Content -->
            <div id="main-content" class="flex-1 bg-slate-800/30 backdrop-blur-xl border border-slate-700/50 shadow-2xl overflow-hidden theme-transition">

                <!-- Calendar Tab -->
                <div id="tab-calendar" class="h-full flex flex-col">
                    <div id="calendar-header" class="p-6 border-b border-slate-700/50 flex justify-between items-center theme-transition">
                        <div class="flex items-center gap-4">
                            <h2 id="calendar-title" class="text-2xl font-semibold theme-text">January 2026</h2>
                            <div class="flex gap-1">
                                <button onclick="navigateMonth(-1)" class="nav-btn w-10 h-10 bg-slate-700/50 hover:bg-slate-600/50 flex items-center justify-center text-white theme-transition">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/></svg>
                                </button>
                                <button onclick="navigateMonth(1)" class="nav-btn w-10 h-10 bg-slate-700/50 hover:bg-slate-600/50 flex items-center justify-center text-white theme-transition">
                                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/></svg>
                                </button>
                            </div>
                        </div>

                        <div class="flex items-center gap-4">
                            <!-- Calendar Legend (dynamic toggles) -->
                            <div id="calendar-legend" class="grid grid-cols-5 gap-x-4 gap-y-1 mr-4" style="max-width: 500px;">
                                <!-- Populated dynamically -->
                            </div>

                            <button onclick="openEventModal()" class="flex items-center gap-2 px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white font-medium">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                                <span>Add Event</span>
                            </button>

                            <div id="view-btn-bg" class="flex gap-1 bg-slate-900/50 p-1">
                                <button onclick="setView('month')" id="view-month" class="view-btn px-5 py-2 text-sm font-medium bg-indigo-600 text-white">Month</button>
                                <button onclick="setView('week')" id="view-week" class="view-btn px-5 py-2 text-sm font-medium text-slate-400 hover:text-white hover:bg-slate-700/50">Week</button>
                                <button onclick="setView('day')" id="view-day" class="view-btn px-5 py-2 text-sm font-medium text-slate-400 hover:text-white hover:bg-slate-700/50">Day</button>
                            </div>
                        </div>
                    </div>

                    <div id="calendar-content" class="flex-1 p-6 overflow-auto">
                        <!-- Calendar grid will be rendered here -->
                    </div>
                </div>

                <!-- Todos Tab -->
                <div id="tab-todos" class="h-full flex flex-col hidden">
                    <div id="todos-header" class="p-4 border-b border-slate-700/50 theme-transition">
                        <h2 class="text-2xl font-semibold theme-text">Tasks</h2>
                    </div>
                    <div id="todos-container" class="flex-1 p-4 overflow-auto">
                        <div id="todos-grid" class="grid gap-4" style="grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));">
                            <!-- Todo lists will be rendered here as vertical sections -->
                        </div>
                    </div>
                </div>

                <!-- Controls Tab (Home Assistant Dashboard) -->
                <div id="tab-controls" class="h-full hidden">
                    <iframe src="dashboard.html" class="controls-frame"></iframe>
                </div>
            </div>
        </div>
        </div> <!-- Close Content Area with Sidebar -->
    </div>

    <script>
        // State
        let currentDate = new Date();
        let currentView = localStorage.getItem('currentView') || 'month';
        let shouldScrollToTime = true; // Only scroll to current time on view switch, not data refresh
        // Dashboard Version
        const DASHBOARD_VERSION = '1.6.0';

        // Connection State (with grace period - show indicator only after 3 consecutive failures)
        let isConnected = true; // Assume connected initially
        let consecutiveFailures = 0;
        const CONNECTION_GRACE_THRESHOLD = 3; // Show indicator after 3 failures
        let connectionRetryCount = 0;
        let connectionRetryInterval = null;
        let connectionBeepContext = null;

        // Connection indicator functions (small, non-intrusive)
        function showConnectionIndicator(message = 'Connecting') {
            const indicator = document.getElementById('connection-indicator');
            const textEl = document.getElementById('connection-text');
            if (indicator) {
                indicator.classList.remove('hidden');
                indicator.classList.toggle('connecting', consecutiveFailures < 5);
            }
            if (textEl) textEl.textContent = message;
        }

        function hideConnectionIndicator() {
            const indicator = document.getElementById('connection-indicator');
            if (indicator) indicator.classList.add('hidden');
            stopConnectionRetry();
            consecutiveFailures = 0;
        }

        function playConnectionBeep() {
            try {
                if (!connectionBeepContext) {
                    connectionBeepContext = new (window.AudioContext || window.webkitAudioContext)();
                }
                const oscillator = connectionBeepContext.createOscillator();
                const gainNode = connectionBeepContext.createGain();
                oscillator.connect(gainNode);
                gainNode.connect(connectionBeepContext.destination);
                oscillator.frequency.value = 440; // A4 note
                oscillator.type = 'sine';
                gainNode.gain.setValueAtTime(0.08, connectionBeepContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, connectionBeepContext.currentTime + 0.1);
                oscillator.start(connectionBeepContext.currentTime);
                oscillator.stop(connectionBeepContext.currentTime + 0.1);
            } catch (e) {
                console.log('Could not play connection beep:', e);
            }
        }

        function startConnectionRetry() {
            if (connectionRetryInterval) return; // Already running
            connectionRetryInterval = setInterval(() => {
                connectionRetryCount++;
                // Only beep after showing the indicator
                if (consecutiveFailures >= CONNECTION_GRACE_THRESHOLD) {
                    playConnectionBeep();
                }
                testConnection();
            }, 10000); // Every 10 seconds
        }

        function stopConnectionRetry() {
            if (connectionRetryInterval) {
                clearInterval(connectionRetryInterval);
                connectionRetryInterval = null;
            }
            connectionRetryCount = 0;
        }

        function handleConnectionFailure() {
            consecutiveFailures++;
            console.log(`Connection attempt failed (${consecutiveFailures}/${CONNECTION_GRACE_THRESHOLD})`);
            
            // Only show indicator after grace threshold
            if (consecutiveFailures >= CONNECTION_GRACE_THRESHOLD) {
                if (isConnected) {
                    isConnected = false;
                    showConnectionIndicator('Reconnecting');
                    startConnectionRetry();
                }
            }
        }

        function handleConnectionSuccess() {
            const wasDisconnected = !isConnected || consecutiveFailures >= CONNECTION_GRACE_THRESHOLD;
            consecutiveFailures = 0;
            isConnected = true;
            hideConnectionIndicator();
            
            if (wasDisconnected) {
                console.log('‚úì Connected to Home Assistant');
            }
        }

        async function testConnection() {
            try {
                const response = await fetch('/api/states', { 
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' },
                    signal: AbortSignal.timeout(5000) // 5 second timeout
                });
                if (response.ok) {
                    const wasDisconnected = consecutiveFailures >= CONNECTION_GRACE_THRESHOLD;
                    handleConnectionSuccess();
                    if (wasDisconnected) {
                        await refreshData();
                    }
                    return true;
                }
            } catch (e) {
                // Connection failed
            }
            handleConnectionFailure();
            return false;
        }

        // Safe date parsing - returns null if invalid
        function safeParseDate(dateStr) {
            if (!dateStr) return null;
            const date = new Date(dateStr);
            if (isNaN(date.getTime())) return null;
            return date;
        }

        // Safe time formatting - returns placeholder if invalid
        function safeFormatTime(dateStr, fallback = '--:--') {
            const date = safeParseDate(dateStr);
            if (!date) return fallback;
            return date.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
        }

        // Kiosk Mode Detection
        const urlParams = new URLSearchParams(window.location.search);
        const KIOSK_MODE = urlParams.get('kiosk') === '1' || urlParams.get('kiosk') === 'true';
        
        if (KIOSK_MODE) {
            // Disable all context menus in kiosk mode
            document.addEventListener('contextmenu', (e) => e.preventDefault());
            // Disable text selection
            document.body.style.userSelect = 'none';
            document.body.style.webkitUserSelect = 'none';
            // Disable drag
            document.addEventListener('dragstart', (e) => e.preventDefault());
            console.log('üñ•Ô∏è Kiosk mode enabled');
        }

        // Temperature conversion helpers
        function fahrenheitToCelsius(f) {
            return Math.round((f - 32) * 5 / 9);
        }

        function celsiusToFahrenheit(c) {
            return Math.round(c * 9 / 5 + 32);
        }

        function formatTempBoth(tempF) {
            const tempC = fahrenheitToCelsius(tempF);
            return `${tempF}¬∞F / ${tempC}¬∞C`;
        }

        function formatTempBothShort(tempF) {
            const tempC = fahrenheitToCelsius(tempF);
            return `${tempF}¬∞/${tempC}¬∞`;
        }

        // Hourly weather forecast storage
        let hourlyForecast = {};

        let activeTab = localStorage.getItem('activeTab') || 'calendar';
        let events = [];
        let isDarkMode = true;

        // Calendar visibility state
        let availableCalendars = []; // Dynamically fetched from HA
        let visibleCalendars = new Set(); // Calendars currently shown

        // Alert state
        let alertedEvents = new Set(); // Track events we've already alerted
        let snoozedEvents = {}; // Track snoozed events with their snooze-until time
        let currentAlertEvent = null;
        let prayerTimes = {}; // Store prayer times for alerts
        let weatherForecast = {}; // Store weather forecast by date
        let autoDismissTimer = null; // Timer for auto-dismissing alarms after 5 minutes
        
        // Track items we've already announced to prevent duplicate announcements
        // Persisted in session storage to survive page reloads within the same session
        let announcedItems = new Set(JSON.parse(sessionStorage.getItem('announcedItems') || '[]'));
        function markAsAnnounced(key) {
            announcedItems.add(key);
            // Keep only last 200 items to prevent memory bloat
            if (announcedItems.size > 200) {
                const arr = Array.from(announcedItems);
                announcedItems = new Set(arr.slice(-100));
            }
            sessionStorage.setItem('announcedItems', JSON.stringify(Array.from(announcedItems)));
        }
        function wasAnnounced(key) {
            return announcedItems.has(key);
        }
        const ALERT_MINUTES_BEFORE = 5; // Alert 5 minutes before event
        const AUTO_DISMISS_MS = 5 * 60 * 1000; // Auto-dismiss alarms after 5 minutes

        // TTS and Alarm configuration
        const TTS_PLATFORM = 'tts.piper'; // Home Assistant TTS platform
        let alarmInterval = null; // Interval for looping alarm
        let alarmAudioContext = null; // Shared audio context for alarm
        let alarmGainNode = null; // Gain node for volume control
        let currentTTSAudio = null; // Current TTS audio element
        let alarmVolume = parseFloat(localStorage.getItem('alarmVolume')) || 0.7; // 0-1 range

        // Default color palette for calendars
        const DEFAULT_COLORS = [
            '#6366f1', // Indigo
            '#f59e0b', // Amber
            '#10b981', // Emerald
            '#ec4899', // Pink
            '#8b5cf6', // Purple
            '#06b6d4', // Cyan
            '#ef4444', // Red
            '#84cc16', // Lime
        ];

        // Specific colors for holiday calendars
        const CALENDAR_COLOR_MAP = {
            'calendar.us_holidays': '#3b82f6',        // Blue - US
            'calendar.islamic_holidays': '#10b981',   // Green - Islamic
            'calendar.christian_holidays': '#8b5cf6', // Purple - Christian
            'calendar.jewish_holidays': '#f59e0b',    // Amber - Jewish
            'calendar.family': '#ec4899',             // Pink - Family
            'calendar.personal': '#6366f1',           // Indigo - Personal
            'calendar.work': '#06b6d4',               // Cyan - Work
            'calendar.kids': '#f97316',               // Orange - Kids
            'calendar.medical': '#ef4444',            // Red - Medical
        };

        let CALENDAR_COLORS = {};

        // Todo lists - dynamically fetched from HA
        let todoLists = [];
        let allTodos = {};

        // API Helper with connection tracking (graceful - 3 failures before showing indicator)
        // Track server version for auto-refresh
        let serverVersion = null;
        
        // Check server version from WebSocket messages - auto-refresh when version changes
        function checkServerVersion(version) {
            if (!version) return;
            if (serverVersion === null) {
                // First time seeing version, store it
                serverVersion = version;
                console.log('Dashboard version:', version);
            } else if (version !== serverVersion) {
                // Version changed - hard refresh!
                console.log('Server version changed:', serverVersion, '->', version, '- refreshing...');
                location.reload(true);
            }
        }
        
        async function fetchHA(endpoint, method = 'GET', body = null) {
            const options = {
                method,
                headers: { 'Content-Type': 'application/json' },
                signal: AbortSignal.timeout(15000) // 15 second timeout
            };
            if (body) options.body = JSON.stringify(body);
            
            try {
                const response = await fetch(endpoint, options);
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                // Check for version change
                const newVersion = response.headers.get('X-Dashboard-Version');
                if (newVersion && serverVersion && newVersion !== serverVersion) {
                    console.log(`Dashboard version changed: ${serverVersion} -> ${newVersion}`);
                    console.log('Reloading page to get latest version...');
                    // Small delay to let current operation complete
                    setTimeout(() => {
                        location.reload(true); // Hard refresh
                    }, 500);
                }
                if (newVersion) {
                    serverVersion = newVersion;
                }
                
                // Connection successful - reset failure counter
                handleConnectionSuccess();
                return response.json();
            } catch (e) {
                console.error(`API error (${endpoint}):`, e.message);
                handleConnectionFailure();
                throw e; // Re-throw so callers can handle
            }
        }

        // Load available calendars from Home Assistant
        async function loadAvailableCalendars() {
            try {
                const states = await fetchHA('/api/states');
                const calendarEntities = states.filter(s => s.entity_id.startsWith('calendar.'));

                availableCalendars = calendarEntities.map((cal, index) => {
                    const entityId = cal.entity_id;
                    const friendlyName = cal.attributes.friendly_name || entityId.replace('calendar.', '').replace(/_/g, ' ');
                    return {
                        entity_id: entityId,
                        name: friendlyName,
                        color: CALENDAR_COLOR_MAP[entityId] || DEFAULT_COLORS[index % DEFAULT_COLORS.length]
                    };
                });

                // Build CALENDAR_COLORS from available calendars
                CALENDAR_COLORS = {};
                availableCalendars.forEach(cal => {
                    CALENDAR_COLORS[cal.entity_id] = cal.color;
                });

                // Load saved visibility from localStorage, default to all visible
                const savedVisibility = localStorage.getItem('calendarVisibility');
                if (savedVisibility) {
                    const savedSet = new Set(JSON.parse(savedVisibility));
                    // Only keep calendars that still exist
                    visibleCalendars = new Set(availableCalendars.map(c => c.entity_id).filter(id => savedSet.has(id)));
                } else {
                    // Default: all calendars visible
                    visibleCalendars = new Set(availableCalendars.map(c => c.entity_id));
                }

                renderCalendarLegend();
                console.log(`Found ${availableCalendars.length} calendars:`, availableCalendars.map(c => c.entity_id));
            } catch (e) {
                console.error('Error loading calendars:', e);
                // Fallback to empty
                availableCalendars = [];
                visibleCalendars = new Set();
            }
        }

        // Load available todo lists from Home Assistant
        async function loadAvailableTodoLists() {
            try {
                const states = await fetchHA('/api/states');
                const todoEntities = states.filter(s => s.entity_id.startsWith('todo.'));

                todoLists = todoEntities.map((todo, index) => {
                    const entityId = todo.entity_id;
                    const friendlyName = todo.attributes.friendly_name || entityId.replace('todo.', '').replace(/_/g, ' ');
                    // Capitalize first letter of each word
                    const name = friendlyName.split(' ').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                    return {
                        entity_id: entityId,
                        name: name,
                        color: DEFAULT_COLORS[index % DEFAULT_COLORS.length]
                    };
                });

                console.log(`Found ${todoLists.length} todo lists:`, todoLists.map(t => t.entity_id));
            } catch (e) {
                console.error('Error loading todo lists:', e);
                todoLists = [];
            }
        }

        // Toggle calendar visibility
        function toggleCalendarVisibility(entityId) {
            if (visibleCalendars.has(entityId)) {
                visibleCalendars.delete(entityId);
            } else {
                visibleCalendars.add(entityId);
            }
            // Save to localStorage
            localStorage.setItem('calendarVisibility', JSON.stringify([...visibleCalendars]));
            renderCalendarLegend();
            renderCalendar();
        }

        // Render the calendar legend with toggle switches
        function renderCalendarLegend() {
            const container = document.getElementById('calendar-legend');
            if (!container) return;

            container.innerHTML = availableCalendars.map(cal => {
                const isVisible = visibleCalendars.has(cal.entity_id);
                const opacity = isVisible ? 'opacity-100' : 'opacity-40';
                return `
                    <label class="flex items-center gap-1.5 cursor-pointer select-none ${opacity} hover:opacity-100 transition-opacity" title="Click to ${isVisible ? 'hide' : 'show'} ${cal.name}">
                        <input type="checkbox"
                            ${isVisible ? 'checked' : ''}
                            onchange="toggleCalendarVisibility('${cal.entity_id}')"
                            class="sr-only">
                        <div class="w-3 h-3 rounded-sm" style="background-color: ${cal.color}"></div>
                        <span class="text-xs text-slate-400">${cal.name}</span>
                    </label>
                `;
            }).join('');
        }

        // Initialize
        async function init() {
            updateClock();
            setInterval(updateClock, 1000);

            // Set version number
            document.getElementById('dashboard-version').textContent = `Skylight Dashboard v${DASHBOARD_VERSION}`;

            // Initial data load - prioritized for fast display
            try {
                resetDismissedIfNewDay(); // Clear dismissed notifications daily
                
                // Priority 1: Calendar (most visible) - load first
                await loadAvailableCalendars();
                await loadCalendarEvents();
                
                // Restore view and render calendar immediately
                shouldScrollToTime = (currentView === 'week' || currentView === 'day');
                setView(currentView);
                setActiveTab(activeTab);
                renderCalendar();
                
                // Mark as connected
                handleConnectionSuccess();
                
                // Priority 2: Load everything else in parallel (background)
                Promise.all([
                    loadMailNotifications(),
                    loadWeather(),
                    loadTodos(),
                    loadAvailableTodoLists()
                ]).catch(e => console.error('Background load error:', e));
                
            } catch (e) {
                console.error('Initial load failed:', e);
                // handleConnectionFailure already called by fetchHA
                // Start retry interval if not already running
                if (consecutiveFailures >= CONNECTION_GRACE_THRESHOLD) {
                    startConnectionRetry();
                }
            }

            // Check for upcoming events every 30 seconds
            checkUpcomingEvents();
            setInterval(checkUpcomingEvents, 30000);

            // Refresh all Home Assistant data every hour (3600000ms)
            setInterval(async () => {
                console.log('Hourly refresh triggered at', new Date().toLocaleTimeString());
                isBackgroundRefresh = true;
                try { await refreshData(); } finally { isBackgroundRefresh = false; }
            }, 3600000);

            // Refresh weather more frequently - every 30 minutes
            setInterval(async () => {
                console.log('Weather refresh triggered at', new Date().toLocaleTimeString());
                isBackgroundRefresh = true;
                try { await loadWeather(); } finally { isBackgroundRefresh = false; }
            }, 1800000);

            // Refresh mail notifications every 15 minutes
            setInterval(async () => {
                console.log('Mail notification refresh at', new Date().toLocaleTimeString());
                isBackgroundRefresh = true;
                try {
                    await loadMailNotifications();
                    
                    // Check for new notifications and announce (only if not already announced)
                    for (const notif of allNotifications) {
                        const key = `notif|${notif.category}|${notif.id || notif.label}`;
                        if (!wasAnnounced(key)) {
                            console.log('New notification detected:', notif.label);
                            markAsAnnounced(key);
                            // Include full message for HA notifications
                            if (notif.category === 'ha_notification' && notif.message) {
                                announceNewItem('notification', `${notif.label}: ${notif.message}`, notif.message);
                            } else {
                                announceNewItem(notif.category === 'ha_notification' ? 'notification' : 'mail', notif.label);
                            }
                            break; // Only announce one at a time
                        }
                    }
                } finally { isBackgroundRefresh = false; }
            }, 900000);

            // Refresh calendar every 5 minutes (in addition to real-time events)
            setInterval(async () => {
                console.log('Calendar refresh at', new Date().toLocaleTimeString());
                isBackgroundRefresh = true;
                try {
                    await loadCalendarEvents();
                    renderCalendar();
                    // Don't announce on periodic refresh - only on WebSocket events for new additions
                } finally { isBackgroundRefresh = false; }
            }, 300000);

            // Schedule daily midnight refresh for fresh forecast data
            scheduleMidnightRefresh();

            // Also refresh when page becomes visible again (e.g., switching tabs back)
            document.addEventListener('visibilitychange', async () => {
                if (document.visibilityState === 'visible') {
                    console.log('Page visible, refreshing data...');
                    await refreshData();
                    checkUpcomingEvents();
                }
            });

            // Initialize screensaver system
            initScreensaver();

            // Initialize camera viewer for doorbell/security cameras
            initCameraViewer();

            // Initialize MQTT bridge for Home Assistant integration
            initMQTTBridge();

            // Check for hourly chime every 30 seconds
            setInterval(checkHourlyChime, 30000);

            // Update time indicator every minute
            setInterval(updateTimeIndicators, 60000);

            // Connection health check every 60 seconds
            setInterval(async () => {
                if (isConnected) {
                    try {
                        await testConnection();
                    } catch (e) {
                        // testConnection handles the error
                    }
                }
            }, 60000);

            console.log('Event alert system initialized - checking every 30 seconds');
        }

        // Update time indicators in week/day views
        function updateTimeIndicators() {
            if (currentView === 'week') {
                updateWeekTimeIndicator();
            } else if (currentView === 'day') {
                updateDayTimeIndicator();
            }
        }

        // Schedule a refresh at midnight for fresh daily forecast data
        function scheduleMidnightRefresh() {
            const now = new Date();
            const midnight = new Date(now);
            midnight.setHours(24, 0, 0, 0); // Next midnight
            const msUntilMidnight = midnight - now;

            setTimeout(async () => {
                console.log('Midnight refresh triggered - fetching fresh forecast data');
                await loadWeather();
                await loadCalendarEvents();
                renderCalendar();

                // Schedule the next midnight refresh (every 24 hours)
                setInterval(async () => {
                    console.log('Daily midnight refresh triggered');
                    await loadWeather();
                    await loadCalendarEvents();
                    renderCalendar();
                }, 86400000); // 24 hours
            }, msUntilMidnight);

            console.log(`Midnight refresh scheduled in ${Math.round(msUntilMidnight / 60000)} minutes`);
        }

        // Clock
        function updateClock() {
            const now = new Date();
            document.getElementById('current-time').textContent = now.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            document.getElementById('current-date').textContent = now.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' });
        }

        // Weather condition icons - using larger, more visible icons
        const WEATHER_ICONS = {
            'clear-night': 'üåô',
            'cloudy': '‚òÅÔ∏è',
            'fog': 'üå´Ô∏è',
            'hail': 'üå®Ô∏è',
            'lightning': '‚õàÔ∏è',
            'lightning-rainy': '‚õàÔ∏è',
            'partlycloudy': '‚õÖ',
            'pouring': 'üåßÔ∏è',
            'rainy': 'üåßÔ∏è',
            'snowy': '‚ùÑÔ∏è',
            'snowy-rainy': 'üå®Ô∏è',
            'sunny': '‚òÄÔ∏è',
            'windy': 'üí®',
            'windy-variant': 'üå¨Ô∏è',
            'exceptional': '‚ö†Ô∏è'
        };

        // Get weather icon based on condition
        function getWeatherIcon(condition) {
            return WEATHER_ICONS[condition] || 'üå°Ô∏è';
        }

        // Play notification sound using Web Audio API
        function playNotificationSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                // Create a pleasant chime sound
                const playTone = (freq, startTime, duration) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';

                    // Envelope
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, startTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);

                    oscillator.start(startTime);
                    oscillator.stop(startTime + duration);
                };

                const now = audioContext.currentTime;

                // Play a pleasant 3-note chime
                playTone(523.25, now, 0.2);       // C5
                playTone(659.25, now + 0.15, 0.2); // E5
                playTone(783.99, now + 0.3, 0.3);  // G5

                // Resume audio context if suspended (autoplay policy)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                console.log('Notification sound played');
            } catch (e) {
                console.error('Error playing notification sound:', e);
            }
        }

        // Text-to-Speech using Home Assistant Piper
        async function speakText(text) {
            try {
                // Stop any currently playing TTS
                if (currentTTSAudio) {
                    currentTTSAudio.pause();
                    currentTTSAudio = null;
                }
                
                // Sanitize text for TTS - remove emojis and clean up newlines
                let cleanText = text
                    .replace(/[\u{1F600}-\u{1F64F}]/gu, '') // emoticons
                    .replace(/[\u{1F300}-\u{1F5FF}]/gu, '') // misc symbols
                    .replace(/[\u{1F680}-\u{1F6FF}]/gu, '') // transport
                    .replace(/[\u{1F1E0}-\u{1F1FF}]/gu, '') // flags
                    .replace(/[\u{2600}-\u{26FF}]/gu, '')   // misc symbols
                    .replace(/[\u{2700}-\u{27BF}]/gu, '')   // dingbats
                    .replace(/\n+/g, '. ')                   // newlines to periods
                    .replace(/\s+/g, ' ')                    // multiple spaces
                    .trim();

                // Get TTS audio URL from Home Assistant
                const response = await fetch('/api/tts_get_url', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        platform: TTS_PLATFORM,
                        message: cleanText
                    })
                });

                if (!response.ok) {
                    throw new Error(`TTS API error: ${response.status}`);
                }

                const result = await response.json();
                const audioUrl = result.url; // Returns something like "/api/tts_proxy/..."

                currentTTSAudio = new Audio(audioUrl);
                currentTTSAudio.volume = alarmVolume; // Apply volume setting
                currentTTSAudio.play();

                currentTTSAudio.onended = () => {
                    currentTTSAudio = null;
                };

                console.log('TTS played via Piper:', text);
            } catch (e) {
                console.error('TTS error (falling back to Web Speech):', e);
                // Fallback to Web Speech API if Piper is not available
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(text);
                    utterance.rate = 0.9;
                    utterance.pitch = 1;
                    utterance.volume = alarmVolume;
                    speechSynthesis.speak(utterance);
                }
            }
        }

        // Announce new calendar events or notifications
        let lastAnnouncementTime = 0;
        const ANNOUNCEMENT_COOLDOWN = 5000; // 5 seconds between announcements

        function announceNewItem(type, itemName, details = '') {
            // Prevent rapid-fire announcements
            const now = Date.now();
            if (now - lastAnnouncementTime < ANNOUNCEMENT_COOLDOWN) {
                console.log('Announcement skipped (cooldown):', type, itemName);
                return;
            }
            lastAnnouncementTime = now;

            let message = '';
            let icon = 'üì¢';
            switch (type) {
                case 'calendar':
                    message = `New calendar event: ${itemName}`;
                    icon = 'üìÖ';
                    break;
                case 'notification':
                    message = `New notification: ${itemName}`;
                    icon = 'üîî';
                    break;
                case 'mail':
                    message = `New mail: ${itemName}`;
                    icon = 'üì¨';
                    break;
                default:
                    message = `New ${type}: ${itemName}`;
            }

            console.log('üì¢ Announcing:', message);
            
            // Add to announcements list for review
            addAnnouncement(type, itemName, details);
            
            // Play a short attention sound first
            playAnnouncementChime().then(() => {
                // Then speak the announcement
                setTimeout(() => speakText(message), 300);
            });
        }

        async function playAnnouncementChime() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const now = audioContext.currentTime;

                // Pleasant two-note chime
                const playNote = (freq, startTime, duration) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    osc.connect(gain);
                    gain.connect(audioContext.destination);
                    osc.frequency.value = freq;
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.2 * alarmVolume, startTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                    osc.start(startTime);
                    osc.stop(startTime + duration);
                };

                playNote(523, now, 0.15);        // C5
                playNote(659, now + 0.15, 0.2);  // E5
                
                return new Promise(resolve => setTimeout(resolve, 400));
            } catch (e) {
                console.log('Could not play announcement chime:', e);
                return Promise.resolve();
            }
        }

        // Set alarm volume (0-100 from slider)
        function setAlarmVolume(value) {
            alarmVolume = value / 100; // Convert to 0-1 range
            localStorage.setItem('alarmVolume', alarmVolume);

            // Update display
            const display = document.getElementById('volume-display');
            if (display) display.textContent = `${value}%`;

            // Update current TTS audio if playing
            if (currentTTSAudio) {
                currentTTSAudio.volume = alarmVolume;
            }

            // Update alarm gain node if alarm is playing
            if (alarmGainNode) {
                alarmGainNode.gain.setValueAtTime(alarmVolume * 0.5, alarmAudioContext.currentTime);
            }

            // Notify MQTT bridge of volume change
            if (mqttBridge) mqttBridge.notifyStateChange();

            console.log('Alarm volume set to:', alarmVolume);
        }

        // Initialize volume slider from saved value
        function initVolumeSlider() {
            const slider = document.getElementById('alarm-volume');
            const display = document.getElementById('volume-display');
            if (slider) {
                const value = Math.round(alarmVolume * 100);
                slider.value = value;
                if (display) display.textContent = `${value}%`;
            }
        }

        // Start looping alarm sound
        let alarmPlayCount = 0; // Track how many times alarm has played for gradual increase

        function startAlarmLoop() {
            // Stop any existing alarm first
            stopAlarm();
            alarmPlayCount = 0;

            // Create audio context for alarm
            alarmAudioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Create master gain node for volume control
            alarmGainNode = alarmAudioContext.createGain();
            alarmGainNode.connect(alarmAudioContext.destination);

            // Start at 10% of target volume
            alarmGainNode.gain.setValueAtTime(alarmVolume * 0.1, alarmAudioContext.currentTime);

            const playAlarmTone = () => {
                if (!alarmAudioContext || alarmAudioContext.state === 'closed') return;

                try {
                    const now = alarmAudioContext.currentTime;
                    alarmPlayCount++;

                    // Gradually increase volume over first 10 plays (20 seconds)
                    const volumeMultiplier = Math.min(1, 0.1 + (alarmPlayCount * 0.09));
                    alarmGainNode.gain.setValueAtTime(alarmVolume * volumeMultiplier * 0.5, now);

                    // Soothing chime with soft attack and decay
                    const playChime = (freq, startTime, duration) => {
                        const oscillator = alarmAudioContext.createOscillator();
                        const gainNode = alarmAudioContext.createGain();

                        oscillator.connect(gainNode);
                        gainNode.connect(alarmGainNode);

                        oscillator.frequency.value = freq;
                        oscillator.type = 'sine';

                        // Soft envelope - gentle fade in and out
                        gainNode.gain.setValueAtTime(0, startTime);
                        gainNode.gain.linearRampToValueAtTime(0.8, startTime + 0.1); // Soft attack
                        gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration); // Gentle decay

                        oscillator.start(startTime);
                        oscillator.stop(startTime + duration);
                    };

                    // Soothing pattern: gentle ascending chime (C-E-G-C major chord arpeggio)
                    playChime(523.25, now, 0.8);          // C5
                    playChime(659.25, now + 0.3, 0.7);    // E5
                    playChime(783.99, now + 0.6, 0.6);    // G5
                    playChime(1046.50, now + 0.9, 0.8);   // C6 (octave)

                    if (alarmAudioContext.state === 'suspended') {
                        alarmAudioContext.resume();
                    }
                } catch (e) {
                    console.error('Error playing alarm tone:', e);
                }
            };

            // Play immediately and then every 3 seconds (slower, more relaxed)
            playAlarmTone();
            alarmInterval = setInterval(playAlarmTone, 3000);

            console.log('Alarm loop started at volume:', alarmVolume);
        }

        // Stop the looping alarm
        function stopAlarm() {
            if (alarmInterval) {
                clearInterval(alarmInterval);
                alarmInterval = null;
            }

            alarmPlayCount = 0; // Reset for next alarm

            if (alarmAudioContext) {
                try {
                    alarmAudioContext.close();
                } catch (e) {
                    // Context might already be closed
                }
                alarmAudioContext = null;
                alarmGainNode = null;
            }

            // Stop TTS if playing
            if (currentTTSAudio) {
                currentTTSAudio.pause();
                currentTTSAudio = null;
            }

            // Stop Web Speech synthesis if active
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
            }

            console.log('Alarm stopped');
        }

        // Weather
        async function loadWeatherCache() {
            // Load cached weather data from server
            try {
                const response = await fetch('/api/weather/cache');
                const cache = await response.json();
                
                // Restore daily forecasts
                if (cache.daily && cache.daily.length > 0) {
                    cache.daily.forEach(f => {
                        const date = safeParseDate(f.date);
                        if (!date) return;
                        const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
                        // Only use cached data if not already loaded
                        if (!weatherForecast[dateKey]) {
                            weatherForecast[dateKey] = {
                                condition: f.condition,
                                high: f.high,
                                low: f.low,
                                highC: f.high_c,
                                lowC: f.low_c,
                                icon: f.icon || getWeatherIcon(f.condition),
                                cached: true
                            };
                        }
                    });
                    console.log('Loaded', cache.daily.length, 'cached daily forecasts');
                }
                
                // Restore hourly forecasts
                if (cache.hourly && cache.hourly.length > 0) {
                    cache.hourly.forEach(f => {
                        const dateKey = f.date.replace(/-/g, '-'); // Keep as YYYY-MM-DD for parsing
                        const dateParts = f.date.split('-');
                        const year = parseInt(dateParts[0]);
                        const month = parseInt(dateParts[1]) - 1; // JS months are 0-indexed
                        const day = parseInt(dateParts[2]);
                        const jsDateKey = `${year}-${month}-${day}`;
                        const hour = f.hour;
                        
                        if (!hourlyForecast[jsDateKey]) {
                            hourlyForecast[jsDateKey] = {};
                        }
                        // Only use cached data if not already loaded
                        if (!hourlyForecast[jsDateKey][hour]) {
                            hourlyForecast[jsDateKey][hour] = {
                                temp: f.temp,
                                tempC: f.temp_c,
                                condition: f.condition || 'unknown',
                                icon: f.icon || getWeatherIcon(f.condition),
                                cached: true
                            };
                        }
                    });
                    console.log('Loaded', cache.hourly.length, 'cached hourly forecasts');
                }
            } catch (e) {
                console.log('Weather cache not available:', e.message);
            }
        }

        async function saveWeatherCache(dailyForecasts, hourlyForecasts) {
            // Save forecasts to server cache
            try {
                if (dailyForecasts && dailyForecasts.length > 0) {
                    const dailyData = dailyForecasts.map(f => ({
                        date: f.datetime ? f.datetime.split('T')[0] : null,
                        high: typeof f.temperature === 'number' ? Math.round(f.temperature) : null,
                        low: typeof f.templow === 'number' ? Math.round(f.templow) : null,
                        high_c: typeof f.temperature === 'number' ? fahrenheitToCelsius(Math.round(f.temperature)) : null,
                        low_c: typeof f.templow === 'number' ? fahrenheitToCelsius(Math.round(f.templow)) : null,
                        condition: f.condition,
                        icon: getWeatherIcon(f.condition),
                        precipitation_probability: f.precipitation_probability
                    })).filter(f => f.date);
                    
                    await fetch('/api/weather/cache/daily', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ forecasts: dailyData })
                    });
                }
                
                if (hourlyForecasts && hourlyForecasts.length > 0) {
                    const hourlyData = hourlyForecasts.map(f => ({
                        datetime: f.datetime,
                        temperature: f.temperature,
                        temp_c: typeof f.temperature === 'number' ? fahrenheitToCelsius(Math.round(f.temperature)) : null,
                        condition: f.condition,
                        icon: getWeatherIcon(f.condition),
                        precipitation_probability: f.precipitation_probability
                    }));
                    
                    await fetch('/api/weather/cache/hourly', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ forecasts: hourlyData })
                    });
                }
            } catch (e) {
                console.log('Failed to save weather cache:', e.message);
            }
        }

        async function loadWeather() {
            try {
                // First load cached data (for historical values)
                await loadWeatherCache();
                
                const states = await fetchHA('/api/states');
                const weather = states.find(s => s.entity_id === 'weather.forecast_home');

                if (weather && weather.attributes) {
                    const attrs = weather.attributes;
                    const temp = typeof attrs.temperature === 'number' ? Math.round(attrs.temperature) : null;
                    const condition = weather.state || 'unknown';
                    const humidity = typeof attrs.humidity === 'number' ? attrs.humidity : null;
                    const windSpeed = typeof attrs.wind_speed === 'number' ? Math.round(attrs.wind_speed) : null;
                    const windUnit = attrs.wind_speed_unit || 'mph';

                    // Show both F and C (or placeholder if no data)
                    if (temp !== null) {
                        const tempC = fahrenheitToCelsius(temp);
                        document.getElementById('weather-temp').textContent = `${temp}¬∞F / ${tempC}¬∞C`;
                    } else {
                        document.getElementById('weather-temp').textContent = '--¬∞F / --¬∞C';
                    }

                    // Format condition name
                    const conditionText = condition.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    document.getElementById('weather-condition').textContent = conditionText;

                    // Update weather icon based on condition
                    document.getElementById('weather-icon').textContent = getWeatherIcon(condition);

                    // Variables to store raw forecasts for caching
                    let rawDailyForecasts = [];
                    let rawHourlyForecasts = [];

                    // Get forecast for high/low and store for calendar
                    try {
                        const forecastResponse = await fetch('/api/services/weather/get_forecasts?return_response', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                entity_id: 'weather.forecast_home',
                                type: 'daily'
                            })
                        });
                        const forecastData = await forecastResponse.json();
                        if (forecastData.service_response && forecastData.service_response['weather.forecast_home']) {
                            const forecasts = forecastData.service_response['weather.forecast_home'].forecast || [];
                            rawDailyForecasts = forecasts;

                            // Store forecast by date for calendar display (overwriting cache with fresh data)
                            forecasts.forEach(f => {
                                const date = safeParseDate(f.datetime);
                                if (!date) return; // Skip invalid dates
                                const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
                                const highF = typeof f.temperature === 'number' ? Math.round(f.temperature) : null;
                                const lowF = typeof f.templow === 'number' ? Math.round(f.templow) : null;
                                weatherForecast[dateKey] = {
                                    condition: f.condition,
                                    high: highF,
                                    low: lowF,
                                    highC: highF !== null ? fahrenheitToCelsius(highF) : null,
                                    lowC: lowF !== null ? fahrenheitToCelsius(lowF) : null,
                                    icon: getWeatherIcon(f.condition)
                                };
                            });

                            // Update today's high/low with both units
                            const todayForecast = forecasts[0];
                            if (todayForecast) {
                                const high = typeof todayForecast.temperature === 'number' ? Math.round(todayForecast.temperature) : null;
                                const low = typeof todayForecast.templow === 'number' ? Math.round(todayForecast.templow) : null;
                                if (high !== null && low !== null) {
                                    const highC = fahrenheitToCelsius(high);
                                    const lowC = fahrenheitToCelsius(low);
                                    document.getElementById('weather-hilo').textContent = `H: ${high}¬∞F/${highC}¬∞C  L: ${low}¬∞F/${lowC}¬∞C`;
                                } else {
                                    document.getElementById('weather-hilo').textContent = 'H: --¬∞F/--¬∞C  L: --¬∞F/--¬∞C';
                                }
                            }

                            // Re-render calendar to show weather
                            if (activeTab === 'calendar') {
                                renderCalendar();
                            }
                        }
                    } catch (e) {
                        console.error('Daily forecast load error:', e);
                    }

                    // Get hourly forecast for week/day views
                    try {
                        const hourlyResponse = await fetch('/api/services/weather/get_forecasts?return_response', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                entity_id: 'weather.forecast_home',
                                type: 'hourly'
                            })
                        });
                        const hourlyData = await hourlyResponse.json();
                        if (hourlyData.service_response && hourlyData.service_response['weather.forecast_home']) {
                            const hourlyForecasts = hourlyData.service_response['weather.forecast_home'].forecast || [];
                            rawHourlyForecasts = hourlyForecasts;
                            
                            // Store hourly forecast by date-hour key (overwriting cache with fresh data)
                            hourlyForecasts.forEach(f => {
                                const date = safeParseDate(f.datetime);
                                if (!date) return; // Skip invalid dates
                                const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
                                const hour = date.getHours();
                                const tempF = typeof f.temperature === 'number' ? Math.round(f.temperature) : null;
                                
                                if (!hourlyForecast[dateKey]) {
                                    hourlyForecast[dateKey] = {};
                                }
                                hourlyForecast[dateKey][hour] = {
                                    temp: tempF,
                                    tempC: tempF !== null ? fahrenheitToCelsius(tempF) : null,
                                    condition: f.condition || 'unknown',
                                    icon: getWeatherIcon(f.condition)
                                };
                            });
                            console.log('Hourly forecast loaded:', Object.keys(hourlyForecast).length, 'days');
                        }
                    } catch (e) {
                        console.error('Hourly forecast load error:', e);
                    }

                    // Save forecasts to cache (async, don't wait)
                    saveWeatherCache(rawDailyForecasts, rawHourlyForecasts);

                    // Update humidity/wind display
                    const extraInfo = document.getElementById('weather-extra');
                    if (extraInfo) {
                        const humidityStr = humidity !== null ? `${humidity}%` : '--%';
                        const windStr = windSpeed !== null ? `${windSpeed} ${windUnit}` : '-- mph';
                        extraInfo.textContent = `üíß ${humidityStr} | üí® ${windStr}`;
                    }
                }

                // Sun data
                const sun = states.find(s => s.entity_id === 'sun.sun');
                if (sun && sun.attributes) {
                    const sunrise = safeParseDate(sun.attributes.next_rising);
                    const sunset = safeParseDate(sun.attributes.next_setting);
                    document.getElementById('sunrise-time').textContent = sunrise 
                        ? sunrise.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
                        : '--:--';
                    document.getElementById('sunset-time').textContent = sunset
                        ? sunset.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
                        : '--:--';

                    // Auto theme based on sun position
                    const isBelowHorizon = sun.state === 'below_horizon';
                    if (isBelowHorizon !== isDarkMode) {
                        setTheme(isBelowHorizon);
                    }
                }

                // Prayer times
                const prayerEntities = {
                    fajr: states.find(s => s.entity_id === 'sensor.islamic_prayer_times_fajr_prayer'),
                    dhuhr: states.find(s => s.entity_id === 'sensor.islamic_prayer_times_dhuhr_prayer'),
                    asr: states.find(s => s.entity_id === 'sensor.islamic_prayer_times_asr_prayer'),
                    maghrib: states.find(s => s.entity_id === 'sensor.islamic_prayer_times_maghrib_prayer'),
                    isha: states.find(s => s.entity_id === 'sensor.islamic_prayer_times_isha_prayer')
                };

                // Store prayer times for alerts
                prayerTimes = {};

                for (const [prayer, entity] of Object.entries(prayerEntities)) {
                    if (entity && entity.state) {
                        const time = safeParseDate(entity.state);
                        if (time) {
                            prayerTimes[prayer] = time;
                        }

                        const el = document.getElementById(`prayer-${prayer}`);
                        if (el) {
                            el.textContent = time 
                                ? time.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true })
                                : '--:--';
                        }
                    }
                }

                // Calculate and display next prayer
                const now = new Date();
                const prayerNames = { fajr: 'Fajr', dhuhr: 'Dhuhr', asr: 'Asr', maghrib: 'Maghrib', isha: 'Isha' };
                let nextPrayer = null;
                let nextPrayerTime = null;

                for (const [prayer, time] of Object.entries(prayerTimes)) {
                    if (time > now) {
                        if (!nextPrayerTime || time < nextPrayerTime) {
                            nextPrayer = prayer;
                            nextPrayerTime = time;
                        }
                    }
                }

                const nextPrayerNameEl = document.getElementById('next-prayer-name');
                const nextPrayerTimeEl = document.getElementById('next-prayer-time');
                if (nextPrayerNameEl && nextPrayerTimeEl) {
                    if (nextPrayer && nextPrayerTime) {
                        nextPrayerNameEl.textContent = prayerNames[nextPrayer];
                        nextPrayerTimeEl.textContent = nextPrayerTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
                    } else {
                        // All prayers passed for today, show Fajr (tomorrow)
                        nextPrayerNameEl.textContent = 'Fajr';
                        nextPrayerTimeEl.textContent = prayerTimes.fajr 
                            ? prayerTimes.fajr.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true }) + ' ‚Å∫¬π'
                            : '--:--';
                    }
                }
            } catch (e) {
                console.error('Weather load error:', e);
            }
        }

        // Notifications System (Mail, Packages, HA Notifications, etc.)
        let haNotifications = []; // Store HA persistent notifications separately
        
        async function loadMailNotifications() {
            try {
                const states = await fetchHA('/api/states');
                const notificationItems = [];

                // === MAIL & PACKAGES ===
                const mailSensors = [
                    { id: 'sensor.mail_usps_mail_2', icon: 'üì¨', label: 'USPS Mail', category: 'mail' },
                    { id: 'sensor.mail_usps_packages_2', icon: 'üì¶', label: 'USPS Package', category: 'mail' },
                    { id: 'sensor.mail_usps_delivering_2', icon: 'üöö', label: 'USPS In Transit', category: 'mail' },
                    { id: 'sensor.mail_amazon_packages_2', icon: 'üì¶', label: 'Amazon Package', category: 'mail' },
                    { id: 'sensor.mail_fedex_packages_2', icon: 'üì¶', label: 'FedEx Package', category: 'mail' },
                    { id: 'sensor.mail_fedex_delivering_2', icon: 'üöö', label: 'FedEx In Transit', category: 'mail' },
                    { id: 'sensor.mail_ups_packages_2', icon: 'üì¶', label: 'UPS Package', category: 'mail' },
                    { id: 'sensor.mail_ups_delivering_2', icon: 'üöö', label: 'UPS In Transit', category: 'mail' },
                    // Fallback to non-_2 sensors
                    { id: 'sensor.mail_usps_mail', icon: 'üì¨', label: 'USPS Mail', category: 'mail', fallback: true },
                    { id: 'sensor.mail_usps_packages', icon: 'üì¶', label: 'USPS Package', category: 'mail', fallback: true },
                    { id: 'sensor.mail_amazon_packages', icon: 'üì¶', label: 'Amazon Package', category: 'mail', fallback: true },
                    { id: 'sensor.mail_fedex_packages', icon: 'üì¶', label: 'FedEx Package', category: 'mail', fallback: true },
                    { id: 'sensor.mail_ups_packages', icon: 'üì¶', label: 'UPS Package', category: 'mail', fallback: true },
                ];

                const seenLabels = new Set();

                for (const sensor of mailSensors) {
                    if (sensor.fallback && seenLabels.has(sensor.label)) continue;

                    const entity = states.find(s => s.entity_id === sensor.id);
                    if (entity && entity.state !== 'unavailable' && entity.state !== 'unknown') {
                        const count = parseInt(entity.state) || 0;
                        if (count > 0) {
                            notificationItems.push({
                                icon: sensor.icon,
                                count: count,
                                label: sensor.label,
                                category: sensor.category,
                                id: sensor.id
                            });
                            seenLabels.add(sensor.label);
                        }
                    }
                }

                // === HOME ASSISTANT PERSISTENT NOTIFICATIONS ===
                // Use dedicated WebSocket API endpoint (HA 2025+ doesn't expose notifications in /api/states)
                try {
                    const response = await fetch('/api/notifications');
                    const data = await response.json();
                    
                    if (data.success && data.notifications) {
                        haNotifications = data.notifications.map(n => ({
                            icon: 'üîî',
                            count: 1,
                            label: n.title || 'Notification',
                            message: n.message || '',
                            category: 'ha_notification',
                            id: `persistent_notification.${n.notification_id}`,
                            notificationId: n.notification_id,
                            createdAt: n.created_at
                        }));

                        // Add HA notifications to the list
                        notificationItems.push(...haNotifications);
                    }
                } catch (e) {
                    console.error('Error loading HA notifications:', e);
                }

                updateMailNotificationUI(notificationItems);
            } catch (e) {
                console.error('Notification load error:', e);
            }
        }

        // Dismiss HA persistent notification
        async function dismissHANotification(notificationId) {
            try {
                await fetchHA('/api/services/persistent_notification/dismiss', 'POST', {
                    notification_id: notificationId
                });
                // Refresh notifications
                await loadMailNotifications();
            } catch (e) {
                console.error('Error dismissing HA notification:', e);
            }
        }

        // Store all notifications (persists across refreshes, dismissed ones stay hidden from header)
        let allNotifications = [];
        let dismissedNotifications = new Set(JSON.parse(localStorage.getItem('dismissedNotifications') || '[]'));
        
        // Store announcements (calendar events, etc.) - persists in sessionStorage
        let recentAnnouncements = JSON.parse(sessionStorage.getItem('recentAnnouncements') || '[]');
        
        function addAnnouncement(type, title, details = '') {
            const announcement = {
                id: `ann_${Date.now()}`,
                type: type,
                title: title,
                details: details,
                time: new Date().toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }),
                timestamp: Date.now()
            };
            recentAnnouncements.unshift(announcement); // Add to beginning
            // Keep only last 20 announcements
            if (recentAnnouncements.length > 20) {
                recentAnnouncements = recentAnnouncements.slice(0, 20);
            }
            sessionStorage.setItem('recentAnnouncements', JSON.stringify(recentAnnouncements));
            updateNotificationsPanel();
            updateMailBadge();
        }
        
        function clearAnnouncement(id) {
            recentAnnouncements = recentAnnouncements.filter(a => a.id !== id);
            sessionStorage.setItem('recentAnnouncements', JSON.stringify(recentAnnouncements));
            updateNotificationsPanel();
            updateMailBadge();
        }
        
        function clearAllAnnouncements() {
            recentAnnouncements = [];
            sessionStorage.setItem('recentAnnouncements', JSON.stringify(recentAnnouncements));
            updateNotificationsPanel();
            updateMailBadge();
        }

        function updateMailNotificationUI(items) {
            const container = document.getElementById('mail-notification');
            const itemsDiv = document.getElementById('mail-items');

            // Store all notifications
            allNotifications = items || [];
            
            // Update the sidebar badge
            updateMailBadge();
            
            // Update the notifications panel
            updateNotificationsPanel();

            // Filter out dismissed items for the header display
            const visibleItems = allNotifications.filter(item => !dismissedNotifications.has(item.label));

            if (!visibleItems || visibleItems.length === 0) {
                container.classList.add('hidden');
                return;
            }

            // Build HTML for header notification (only non-dismissed)
            let html = '';
            for (const item of visibleItems) {
                html += `
                    <div class="mail-item">
                        <span class="mail-icon">${item.icon}</span>
                        <div>
                            <div class="mail-count">${item.count}</div>
                            <div class="mail-label">${item.label}</div>
                        </div>
                    </div>
                `;
            }

            itemsDiv.innerHTML = html;
            container.classList.remove('hidden');
        }

        function updateMailBadge() {
            const badge = document.getElementById('mail-badge');
            const notifCount = allNotifications ? allNotifications.reduce((sum, item) => sum + item.count, 0) : 0;
            const announcementCount = recentAnnouncements.length;
            const totalCount = notifCount + announcementCount;
            
            if (totalCount > 0) {
                badge.textContent = totalCount > 99 ? '99+' : totalCount;
                badge.classList.remove('hidden');
            } else {
                badge.classList.add('hidden');
            }
        }

        function toggleNotificationsPanel() {
            const panel = document.getElementById('notifications-panel');
            panel.classList.toggle('hidden');
        }

        function closeNotificationsPanel() {
            const panel = document.getElementById('notifications-panel');
            panel.classList.add('hidden');
        }

        function hideMailNotification() {
            const container = document.getElementById('mail-notification');
            container.classList.add('hidden');
        }

        function updateNotificationsPanel() {
            const listDiv = document.getElementById('notifications-list');
            
            const hasNotifications = (allNotifications && allNotifications.length > 0) || recentAnnouncements.length > 0;
            
            if (!hasNotifications) {
                listDiv.innerHTML = '<div class="notifications-empty">üì≠ No notifications</div>';
                return;
            }

            // Group notifications by category
            const mailItems = allNotifications ? allNotifications.filter(n => n.category === 'mail') : [];
            const haItems = allNotifications ? allNotifications.filter(n => n.category === 'ha_notification') : [];

            let html = '';
            
            // Recent Announcements section (at top)
            if (recentAnnouncements.length > 0) {
                html += `
                    <div class="text-xs text-slate-500 px-2 py-1 font-semibold flex justify-between items-center">
                        <span>üì£ RECENT ANNOUNCEMENTS</span>
                        <button onclick="clearAllAnnouncements()" class="text-[10px] text-slate-400 hover:text-red-400" title="Clear all">Clear</button>
                    </div>`;
                for (const ann of recentAnnouncements) {
                    const icon = ann.type === 'calendar' ? 'üìÖ' : ann.type === 'notification' ? 'üîî' : ann.type === 'mail' ? 'üì¨' : 'üì¢';
                    html += `
                        <div class="notification-item">
                            <span class="notification-icon">${icon}</span>
                            <div class="notification-content">
                                <div class="notification-label">${ann.title}</div>
                                <div class="notification-count text-xs text-slate-400">${ann.time}${ann.details ? ' ‚Ä¢ ' + ann.details.substring(0, 30) : ''}</div>
                            </div>
                            <button class="notification-dismiss" onclick="clearAnnouncement('${ann.id}')" title="Dismiss">‚úï</button>
                        </div>
                    `;
                }
            }

            // Mail & Packages section
            if (mailItems.length > 0) {
                html += '<div class="text-xs text-slate-500 px-2 py-1 mt-2 font-semibold">üì¨ MAIL & PACKAGES</div>';
                for (const item of mailItems) {
                    const isDismissed = dismissedNotifications.has(item.label);
                    html += `
                        <div class="notification-item ${isDismissed ? 'opacity-50' : ''}">
                            <span class="notification-icon">${item.icon}</span>
                            <div class="notification-content">
                                <div class="notification-label">${item.label}</div>
                                <div class="notification-count">${item.count} item${item.count > 1 ? 's' : ''}</div>
                            </div>
                            ${!isDismissed ? `<button class="notification-dismiss" onclick="dismissNotification('${item.label}')" title="Hide from header">‚úï</button>` : ''}
                        </div>
                    `;
                }
            }

            // HA Notifications section
            if (haItems.length > 0) {
                html += '<div class="text-xs text-slate-500 px-2 py-1 mt-2 font-semibold">üîî HOME ASSISTANT</div>';
                for (const item of haItems) {
                    html += `
                        <div class="notification-item">
                            <span class="notification-icon">${item.icon}</span>
                            <div class="notification-content">
                                <div class="notification-label">${item.label}</div>
                                ${item.message ? `<div class="notification-count text-xs">${item.message.substring(0, 50)}${item.message.length > 50 ? '...' : ''}</div>` : ''}
                            </div>
                            <button class="notification-dismiss" onclick="dismissHANotification('${item.notificationId}')" title="Dismiss notification">‚úï</button>
                        </div>
                    `;
                }
            }

            listDiv.innerHTML = html;
        }

        function dismissNotification(label) {
            dismissedNotifications.add(label);
            localStorage.setItem('dismissedNotifications', JSON.stringify([...dismissedNotifications]));
            
            // Update displays
            updateMailNotificationUI(allNotifications);
        }

        // Clear dismissed notifications daily (or when mail count changes significantly)
        function resetDismissedIfNewDay() {
            const lastReset = localStorage.getItem('dismissedResetDate');
            const today = new Date().toDateString();
            if (lastReset !== today) {
                dismissedNotifications.clear();
                localStorage.setItem('dismissedNotifications', '[]');
                localStorage.setItem('dismissedResetDate', today);
            }
        }

        // Close notifications panel when clicking outside
        document.addEventListener('click', (e) => {
            const panel = document.getElementById('notifications-panel');
            const mailBtn = document.getElementById('btn-mail');
            if (!panel.classList.contains('hidden') && 
                !panel.contains(e.target) && 
                !mailBtn.contains(e.target)) {
                closeNotificationsPanel();
            }
        });

        // Theme switching
        function setTheme(dark) {
            isDarkMode = dark;
            const root = document.documentElement;

            if (dark) {
                root.style.setProperty('--bg-primary', '#0f172a');
                root.style.setProperty('--bg-secondary', '#1e293b');
                root.style.setProperty('--bg-card', '#334155');
                root.style.setProperty('--text-primary', '#ffffff');
                root.style.setProperty('--text-secondary', '#94a3b8');
                root.style.setProperty('--text-muted', '#64748b');
                root.style.setProperty('--border-color', '#475569');
            } else {
                root.style.setProperty('--bg-primary', '#f8fafc');
                root.style.setProperty('--bg-secondary', '#ffffff');
                root.style.setProperty('--bg-card', '#f1f5f9');
                root.style.setProperty('--text-primary', '#1e293b');
                root.style.setProperty('--text-secondary', '#475569');
                root.style.setProperty('--text-muted', '#94a3b8');
                root.style.setProperty('--border-color', '#e2e8f0');
            }

            applyThemeClasses(dark);
            console.log('Theme set to:', dark ? 'dark' : 'light');
        }

        function toggleTheme() {
            setTheme(!isDarkMode);
        }

        function applyThemeClasses(dark) {
            // Toggle root class
            document.documentElement.classList.toggle('light', !dark);

            // Body background
            document.body.className = dark
                ? 'bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 min-h-screen'
                : 'bg-gradient-to-br from-blue-50 via-white to-slate-100 min-h-screen';

            // Sidebar
            const sidebar = document.getElementById('sidebar');
            if (sidebar) {
                sidebar.className = dark
                    ? 'w-20 bg-slate-900/50 backdrop-blur-xl border-r border-slate-700/50 flex flex-col items-center py-8 gap-2 theme-transition'
                    : 'w-20 bg-white/80 backdrop-blur-xl border-r border-slate-200 flex flex-col items-center py-8 gap-2 shadow-lg theme-transition';
            }

            // Sidebar buttons
            document.querySelectorAll('.sidebar-btn').forEach(btn => {
                if (!btn.classList.contains('bg-indigo-600')) {
                    // Remove all theme-related classes
                    btn.classList.remove(
                        'bg-slate-800/50', 'bg-slate-100', 'bg-white',
                        'hover:bg-slate-700/50', 'hover:bg-slate-200',
                        'text-slate-400', 'text-slate-600', 'text-gray-600',
                        'hover:text-white', 'hover:text-slate-800'
                    );
                    if (dark) {
                        btn.classList.add('bg-slate-800/50', 'hover:bg-slate-700/50', 'text-slate-400', 'hover:text-white');
                    } else {
                        btn.classList.add('bg-slate-100', 'hover:bg-slate-200', 'text-slate-600', 'hover:text-slate-800');
                    }
                }
            });

            // Sunrise/sunset border
            document.querySelectorAll('.border-slate-700\\/50').forEach(el => {
                if (el.classList.contains('border-l') || el.classList.contains('border-r')) {
                    el.classList.toggle('border-slate-700/50', dark);
                    el.classList.toggle('border-slate-300', !dark);
                }
            });

            // Main content area
            const mainContent = document.getElementById('main-content');
            if (mainContent) {
                mainContent.className = dark
                    ? 'flex-1 bg-slate-800/30 backdrop-blur-xl border border-slate-700/50 shadow-2xl overflow-hidden theme-transition'
                    : 'flex-1 bg-white/80 backdrop-blur-xl border border-slate-200 shadow-2xl overflow-hidden theme-transition';
            }

            // Calendar header
            const calendarHeader = document.getElementById('calendar-header');
            if (calendarHeader) {
                calendarHeader.className = dark
                    ? 'p-6 border-b border-slate-700/50 flex justify-between items-center theme-transition'
                    : 'p-6 border-b border-slate-200 flex justify-between items-center theme-transition';
            }

            // Text elements
            document.querySelectorAll('.text-white').forEach(el => {
                if (!el.closest('.bg-indigo-600') && !el.closest('[style*="background"]')) {
                    el.classList.toggle('text-white', dark);
                    el.classList.toggle('text-slate-800', !dark);
                }
            });

            document.querySelectorAll('.text-slate-400').forEach(el => {
                el.classList.toggle('text-slate-400', dark);
                el.classList.toggle('text-slate-500', !dark);
            });

            // Time display
            const timeDisplay = document.getElementById('current-time');
            if (timeDisplay) {
                timeDisplay.className = dark
                    ? 'text-5xl font-light text-white tracking-tight theme-text'
                    : 'text-5xl font-light text-slate-800 tracking-tight theme-text';
            }

            const dateDisplay = document.getElementById('current-date');
            if (dateDisplay) {
                dateDisplay.className = dark
                    ? 'text-slate-400 text-sm mt-1 theme-text-muted'
                    : 'text-slate-500 text-sm mt-1 theme-text-muted';
            }

            // Navigation buttons
            document.querySelectorAll('.nav-btn').forEach(btn => {
                btn.className = dark
                    ? 'w-10 h-10 bg-slate-700/50 hover:bg-slate-600/50 flex items-center justify-center text-white theme-transition'
                    : 'w-10 h-10 bg-slate-100 hover:bg-slate-200 flex items-center justify-center text-slate-700 theme-transition';
            });

            // View buttons background
            const viewBtnBg = document.getElementById('view-btn-bg');
            if (viewBtnBg) {
                viewBtnBg.className = dark
                    ? 'flex gap-1 bg-slate-900/50 p-1'
                    : 'flex gap-1 bg-slate-100 p-1';
            }

            // Update theme icon
            const themeIcon = document.getElementById('theme-icon');
            if (themeIcon) {
                themeIcon.textContent = dark ? '‚òÄÔ∏è' : 'üåô';
            }

            // Todos header
            const todosHeader = document.getElementById('todos-header');
            if (todosHeader) {
                todosHeader.className = dark
                    ? 'p-4 border-b border-slate-700/50 theme-transition'
                    : 'p-4 border-b border-slate-200 theme-transition';
            }

            // Re-render calendar to apply new theme
            if (typeof renderCalendar === 'function') {
                renderCalendar();
            }

            // Re-render todos to apply new theme
            if (typeof renderTodos === 'function') {
                renderTodos();
            }
        }

        // Calendar Events
        async function loadCalendarEvents() {
            try {
                const start = new Date(currentDate.getFullYear(), currentDate.getMonth(), 1);
                const end = new Date(currentDate.getFullYear(), currentDate.getMonth() + 2, 0);

                // Format dates for HA API (local time without timezone)
                const formatDate = (d) => {
                    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}T00:00:00`;
                };
                const formatEndDate = (d) => {
                    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')}T23:59:59`;
                };

                // Use dynamically fetched calendars, only load visible ones
                const calendarsToLoad = availableCalendars.map(c => c.entity_id);
                console.log(`Loading events from ${calendarsToLoad.length} calendars:`, calendarsToLoad);
                events = [];

                // Parse event dates helper
                const parseEventDate = (dateVal) => {
                    if (!dateVal) return new Date();
                    
                    // Handle object format from HA: {date: "..."} or {dateTime: "..."}
                    let dateStr = dateVal;
                    if (typeof dateVal === 'object') {
                        dateStr = dateVal.dateTime || dateVal.date || '';
                    }
                    
                    if (!dateStr) return new Date();
                    
                    // If it's just a date (YYYY-MM-DD), parse as local midnight
                    if (/^\d{4}-\d{2}-\d{2}$/.test(dateStr)) {
                        const [year, month, day] = dateStr.split('-').map(Number);
                        return new Date(year, month - 1, day);
                    }
                    // Otherwise parse normally (has time component)
                    return new Date(dateStr);
                };

                // Fetch all calendars in parallel for faster loading
                const calendarPromises = calendarsToLoad.map(async (cal) => {
                    try {
                        const response = await fetch(`/api/services/calendar/get_events?return_response&_t=${Date.now()}`, {
                            method: 'POST',
                            headers: { 
                                'Content-Type': 'application/json',
                                'Cache-Control': 'no-cache'
                            },
                            body: JSON.stringify({
                                entity_id: cal,
                                start_date_time: formatDate(start),
                                end_date_time: formatEndDate(end)
                            })
                        });

                        const result = await response.json();

                        if (result.service_response && result.service_response[cal]) {
                            const calEvents = result.service_response[cal].events || [];
                            return calEvents.map(e => ({
                                ...e,
                                calendar: cal,
                                color: CALENDAR_COLORS[cal],
                                startDate: parseEventDate(e.start),
                                endDate: parseEventDate(e.end)
                            }));
                        }
                        return [];
                    } catch (err) {
                        console.error(`Error loading ${cal}:`, err);
                        return [];
                    }
                });

                // Wait for all calendars to load
                const results = await Promise.all(calendarPromises);
                events = results.flat();

                console.log(`Loaded ${events.length} events`);
                renderCalendar();
            } catch (e) {
                console.error('Calendar load error:', e);
            }
        }

        // Todos - Load all lists
        async function loadTodos() {
            try {
                // Fetch all todo lists in parallel
                const promises = todoLists.map(async (list) => {
                    try {
                        const result = await fetchHA(`/api/services/todo/get_items?return_response`, 'POST', {
                            entity_id: list.entity_id
                        });
                        if (result.service_response && result.service_response[list.entity_id]) {
                            return { listId: list.entity_id, items: result.service_response[list.entity_id].items || [] };
                        }
                        return { listId: list.entity_id, items: [] };
                    } catch (err) {
                        console.error(`Error loading ${list.entity_id}:`, err);
                        return { listId: list.entity_id, items: [] };
                    }
                });

                const results = await Promise.all(promises);
                allTodos = {};
                results.forEach(r => {
                    allTodos[r.listId] = r.items;
                });

                renderTodos();
            } catch (e) {
                console.error('Todos load error:', e);
            }
        }

        // Render all todo lists as vertical sections
        function renderTodos() {
            const container = document.getElementById('todos-grid');
            if (!container) return;

            const dark = isDarkMode;

            container.innerHTML = todoLists.map(list => {
                const items = allTodos[list.entity_id] || [];
                const completed = items.filter(t => t.status === 'completed').length;
                const total = items.length;
                const progressPercent = total > 0 ? (completed / total) * 100 : 0;

                return `
                    <div class="flex flex-col ${dark ? 'bg-slate-800/50 border-slate-700/50' : 'bg-white border-slate-200'} border overflow-hidden h-full" style="min-height: 300px; max-height: calc(100vh - 200px);">
                        <!-- List Header -->
                        <div class="p-3 ${dark ? 'border-slate-700/50' : 'border-slate-200'} border-b flex items-center justify-between" style="background-color: ${list.color}20;">
                            <div class="flex items-center gap-2">
                                <div class="w-3 h-3 rounded-sm" style="background-color: ${list.color}"></div>
                                <span class="font-semibold ${dark ? 'text-white' : 'text-slate-800'}">${list.name}</span>
                                <span class="text-xs ${dark ? 'text-slate-400' : 'text-slate-500'}">(${completed}/${total})</span>
                            </div>
                        </div>

                        <!-- Add Task Input -->
                        <div class="p-2 ${dark ? 'border-slate-700/30' : 'border-slate-200'} border-b">
                            <div class="flex gap-2">
                                <input type="text"
                                    id="add-todo-${list.entity_id.replace('.', '-')}"
                                    placeholder="Add task..."
                                    class="flex-1 px-3 py-2 ${dark ? 'bg-slate-700/50 border-slate-600/50 text-white placeholder-slate-500' : 'bg-slate-50 border-slate-300 text-slate-800 placeholder-slate-400'} border text-sm focus:outline-none focus:ring-1 focus:ring-opacity-50"
                                    style="--tw-ring-color: ${list.color}"
                                    onkeypress="if(event.key==='Enter') addTodoToList('${list.entity_id}', this.value, this)">
                                <button onclick="addTodoFromInput('${list.entity_id}')"
                                    class="px-3 py-2 text-white text-sm font-medium hover:opacity-80 transition-opacity"
                                    style="background-color: ${list.color}">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                                </button>
                            </div>
                        </div>

                        <!-- Progress Bar -->
                        <div class="h-1 ${dark ? 'bg-slate-700/50' : 'bg-slate-200'}">
                            <div class="h-full transition-all duration-300" style="width: ${progressPercent}%; background-color: ${list.color}"></div>
                        </div>

                        <!-- Todo Items -->
                        <div class="flex-1 overflow-y-auto p-2 space-y-1">
                            ${items.length === 0 ? `
                                <div class="text-center py-8 ${dark ? 'text-slate-500' : 'text-slate-400'} text-sm">No tasks</div>
                            ` : items.map((todo, index) => {
                                const isCompleted = todo.status === 'completed';
                                return `
                                    <div class="todo-item p-2 cursor-pointer rounded ${isCompleted ? (dark ? 'bg-slate-700/10' : 'bg-slate-100/50') + ' opacity-50' : (dark ? 'bg-slate-700/30 hover:bg-slate-700/50' : 'bg-slate-100 hover:bg-slate-200')}"
                                         onclick="toggleTodo('${list.entity_id}', '${todo.uid}', ${isCompleted})"
                                         style="animation: fadeIn 0.2s ease-out forwards; animation-delay: ${index * 30}ms">
                                        <div class="flex items-center gap-2">
                                            <div class="w-5 h-5 border-2 flex-shrink-0 flex items-center justify-center rounded-sm ${isCompleted ? 'border-transparent' : ''}"
                                                 style="${isCompleted ? `background-color: ${list.color}` : `border-color: ${list.color}50`}">
                                                ${isCompleted ? '<svg class="w-3 h-3 text-white" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M5 13l4 4L19 7"/></svg>' : ''}
                                            </div>
                                            <div class="flex-1 min-w-0">
                                                <div class="text-sm ${isCompleted ? 'text-slate-500 line-through' : (dark ? 'text-white' : 'text-slate-800')} truncate">${todo.summary}</div>
                                            </div>
                                            <button onclick="event.stopPropagation(); deleteTodo('${list.entity_id}', '${todo.uid}')"
                                                class="w-6 h-6 flex-shrink-0 flex items-center justify-center text-slate-500 hover:text-red-400 hover:bg-red-500/20 rounded transition-colors">
                                                <svg class="w-3 h-3" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/></svg>
                                            </button>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            }).join('');
        }

        async function toggleTodo(listId, uid, isCompleted) {
            try {
                await fetchHA('/api/services/todo/update_item', 'POST', {
                    entity_id: listId,
                    item: uid,
                    status: isCompleted ? 'needs_action' : 'completed'
                });
                await loadTodos();
            } catch (e) {
                console.error('Toggle todo error:', e);
            }
        }

        async function deleteTodo(listId, uid) {
            try {
                await fetchHA('/api/services/todo/remove_item', 'POST', {
                    entity_id: listId,
                    item: uid
                });
                await loadTodos();
            } catch (e) {
                console.error('Delete todo error:', e);
            }
        }

        function addTodoFromInput(listId) {
            const inputId = `add-todo-${listId.replace('.', '-')}`;
            const input = document.getElementById(inputId);
            if (input && input.value.trim()) {
                addTodoToList(listId, input.value.trim(), input);
            }
        }

        async function addTodoToList(listId, text, inputElement) {
            if (!text || !text.trim()) return;
            try {
                await fetchHA('/api/services/todo/add_item', 'POST', {
                    entity_id: listId,
                    item: text.trim()
                });
                if (inputElement) {
                    inputElement.value = '';
                }
                await loadTodos();
            } catch (e) {
                console.error('Add todo error:', e);
            }
        }

        // Calendar Rendering
        function renderCalendar() {
            const title = currentView === 'day'
                ? currentDate.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric', year: 'numeric' })
                : currentDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            document.getElementById('calendar-title').textContent = title;

            const container = document.getElementById('calendar-content');
            
            // Save scroll position before re-rendering (for week/day views)
            let savedScrollTop = 0;
            const existingGrid = document.getElementById('week-time-grid') || document.getElementById('day-time-grid');
            if (existingGrid && !shouldScrollToTime) {
                savedScrollTop = existingGrid.scrollTop;
            }

            if (currentView === 'month') {
                renderMonthView(container);
            } else if (currentView === 'week') {
                renderWeekView(container);
            } else {
                renderDayView(container);
            }
            
            // Restore scroll position after rendering (if not scrolling to current time)
            if (savedScrollTop > 0 && !shouldScrollToTime) {
                const newGrid = document.getElementById('week-time-grid') || document.getElementById('day-time-grid');
                if (newGrid) {
                    // Use setTimeout to ensure DOM is fully rendered
                    setTimeout(() => {
                        newGrid.scrollTop = savedScrollTop;
                    }, 60);
                }
            }
        }

        function renderMonthView(container) {
            const year = currentDate.getFullYear();
            const month = currentDate.getMonth();
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();
            const daysInPrevMonth = new Date(year, month, 0).getDate();

            const days = [];
            for (let i = firstDay - 1; i >= 0; i--) {
                days.push({ day: daysInPrevMonth - i, isCurrentMonth: false });
            }
            for (let i = 1; i <= daysInMonth; i++) {
                days.push({ day: i, isCurrentMonth: true });
            }
            const remaining = 42 - days.length;
            for (let i = 1; i <= remaining; i++) {
                days.push({ day: i, isCurrentMonth: false });
            }

            const today = new Date();

            const dark = isDarkMode;
            container.innerHTML = `
                <div class="h-full flex flex-col">
                    <div class="grid grid-cols-7 gap-2 sticky top-0 z-10 ${dark ? 'bg-slate-800/95' : 'bg-white/95'} backdrop-blur-sm pb-2">
                        ${['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'].map((d, i) => {
                            // Check if this day column contains today
                            const todayDayOfWeek = today.getDay();
                            const isCurrentDayColumn = i === todayDayOfWeek &&
                                month === today.getMonth() && year === today.getFullYear();
                            return `<div class="text-center text-sm font-medium py-2 ${isCurrentDayColumn ? 'text-indigo-400' : (dark ? 'text-slate-400' : 'text-slate-500')}">${d}</div>`;
                        }).join('')}
                    </div>
                    <div class="grid grid-cols-7 gap-2 flex-1 overflow-auto">
                        ${days.map((item, index) => {
                            const dayEvents = item.isCurrentMonth ? getEventsForDay(item.day) : [];
                            const isToday = item.isCurrentMonth && item.day === today.getDate() &&
                                month === today.getMonth() && year === today.getFullYear();

                            // Get weather for this day
                            const dateKey = `${year}-${month}-${item.day}`;
                            const dayWeather = item.isCurrentMonth ? weatherForecast[dateKey] : null;

                            const cellBg = isToday
                                ? (dark ? 'bg-indigo-900/40 hover:bg-indigo-900/50 ring-2 ring-indigo-500/50' : 'bg-indigo-100 hover:bg-indigo-200 ring-2 ring-indigo-400/50')
                                : item.isCurrentMonth
                                    ? (dark ? 'bg-slate-700/30 hover:bg-slate-700/50' : 'bg-slate-50 hover:bg-slate-100')
                                    : (dark ? 'bg-slate-800/20' : 'bg-slate-100/50');

                            const dayTextColor = isToday
                                ? 'bg-indigo-600 text-white'
                                : item.isCurrentMonth
                                    ? (dark ? 'text-white' : 'text-slate-800')
                                    : (dark ? 'text-slate-600' : 'text-slate-400');

                            return `
                                <div onclick="handleDayClick(${item.day}, ${item.isCurrentMonth})"
                                     class="day-cell min-h-24 p-2 cursor-pointer ${cellBg}">
                                    <div class="flex justify-between items-start mb-1">
                                        <div class="text-sm font-medium w-7 h-7 flex items-center justify-center ${dayTextColor}">${item.day}</div>
                                        ${dayWeather ? `
                                            <div class="text-right">
                                                <div class="text-base leading-none">${dayWeather.icon}</div>
                                                <div class="text-[10px] ${dark ? 'text-slate-400' : 'text-slate-500'}">${dayWeather.high}¬∞/${dayWeather.low}¬∞</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div class="space-y-1">
                                        ${dayEvents.slice(0, 2).map((e, idx) =>
                                            `<div onclick="event.stopPropagation(); showEventDetails(events.find(ev => ev.summary === '${e.summary.replace(/'/g, "\\'")}' && ev.start === '${e.start}'))" class="event-badge text-xs px-2 py-1 truncate text-white font-medium cursor-pointer hover:opacity-80" style="background-color: ${e.color}">${e.summary}</div>`
                                        ).join('')}
                                        ${dayEvents.length > 2 ? `<div class="text-xs ${dark ? 'text-slate-400' : 'text-slate-500'} pl-2">+${dayEvents.length - 2} more</div>` : ''}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
        }

        function renderWeekView(container) {
            const startOfWeek = new Date(currentDate);
            startOfWeek.setDate(currentDate.getDate() - currentDate.getDay());

            const weekDays = Array.from({ length: 7 }, (_, i) => {
                const date = new Date(startOfWeek);
                date.setDate(startOfWeek.getDate() + i);
                return date;
            });

            const hours = Array.from({ length: 24 }, (_, i) => i); // Full 24 hours
            const today = new Date();
            const dark = isDarkMode;

            // Check if current week contains today
            const todayIndex = weekDays.findIndex(d => d.toDateString() === today.toDateString());
            const showTimeLine = todayIndex !== -1;

            // Get all-day events for each day
            const getAllDayEvents = (date) => {
                return events.filter(e => {
                    if (!visibleCalendars.has(e.calendar)) return false;
                    const eventDate = e.startDate;
                    const eventEndDate = e.endDate;
                    const isAllDay = eventDate.getHours() === 0 && eventDate.getMinutes() === 0 &&
                                    eventEndDate.getHours() === 0 && eventEndDate.getMinutes() === 0;
                    if (!isAllDay) return false;
                    const sameDay = eventDate.getDate() === date.getDate() &&
                                   eventDate.getMonth() === date.getMonth() &&
                                   eventDate.getFullYear() === date.getFullYear();
                    return sameDay;
                });
            };

            // Check if any day has all-day events
            const hasAnyAllDayEvents = weekDays.some(d => getAllDayEvents(d).length > 0);

            container.innerHTML = `
                <div class="h-full flex flex-col">
                    <div class="grid grid-cols-8 gap-2 pb-2 sticky top-0 z-10 ${dark ? 'bg-slate-800/95' : 'bg-white/95'} backdrop-blur-sm">
                        <div class="w-16"></div>
                        ${weekDays.map(date => {
                            const isToday = date.toDateString() === today.toDateString();
                            const dateKey = `${date.getFullYear()}-${date.getMonth()}-${date.getDate()}`;
                            const dayWeather = weatherForecast[dateKey];
                            return `
                                <div class="text-center cursor-pointer" onclick="goToDay(${date.getTime()})">
                                    <div class="flex items-center justify-center gap-1">
                                        <span class="${isToday ? 'text-indigo-400' : (dark ? 'text-slate-400' : 'text-slate-500')} text-sm font-medium">${date.toLocaleDateString('en-US', { weekday: 'short' })}</span>
                                        ${dayWeather ? `<span class="text-sm">${dayWeather.icon}</span>` : ''}
                                    </div>
                                    <div class="text-lg font-semibold mt-1 w-10 h-10 mx-auto flex items-center justify-center ${isToday ? 'bg-indigo-600 text-white' : (dark ? 'text-white hover:bg-slate-700/30' : 'text-slate-800 hover:bg-slate-200')}">${date.getDate()}</div>
                                    ${dayWeather ? `<div class="text-[10px] ${dark ? 'text-slate-400' : 'text-slate-500'}">${dayWeather.high}¬∞/${dayWeather.highC}¬∞</div>` : ''}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    ${hasAnyAllDayEvents ? `
                    <div class="grid grid-cols-8 gap-2 pb-2 border-b ${dark ? 'border-slate-700' : 'border-slate-200'}">
                        <div class="${dark ? 'text-slate-400' : 'text-slate-500'} text-xs w-16 text-right pr-2 pt-1">All Day</div>
                        ${weekDays.map(date => {
                            const allDayEvents = getAllDayEvents(date);
                            const isToday = date.toDateString() === today.toDateString();
                            return `
                                <div class="${isToday ? (dark ? 'bg-indigo-900/20' : 'bg-indigo-50') : ''} min-h-8 p-1">
                                    ${allDayEvents.map(e => `<div onclick="showEventDetails(events.find(ev => ev.summary === '${e.summary.replace(/'/g, "\\'")}' && ev.start === '${e.start}'))" class="text-xs px-1 py-0.5 mb-0.5 truncate text-white font-medium cursor-pointer hover:opacity-80 rounded" style="background-color: ${e.color}">${e.summary}</div>`).join('')}
                                </div>
                            `;
                        }).join('')}
                    </div>
                    ` : ''}
                    <div id="week-time-grid" class="space-y-1 overflow-auto relative flex-1">
                        ${hours.map(hour => `
                            <div class="grid grid-cols-8 gap-2 min-h-16 hour-row" data-hour="${hour}">
                                <div class="${dark ? 'text-slate-400' : 'text-slate-500'} text-xs w-16 text-right pr-2 pt-1">${formatHour(hour)}</div>
                                ${weekDays.map(date => {
                                    const dayEvents = getEventsForDateTime(date, hour);
                                    const isToday = date.toDateString() === today.toDateString();
                                    const dateKey = date.getFullYear() + '-' + date.getMonth() + '-' + date.getDate();
                                    const hourWeather = hourlyForecast[dateKey] ? hourlyForecast[dateKey][hour] : null;
                                    return `
                                        <div class="${isToday ? (dark ? 'bg-indigo-900/30 border-indigo-500/50' : 'bg-indigo-100 border-indigo-300') : (dark ? 'bg-slate-700/20 border-slate-700/30' : 'bg-slate-50 border-slate-200')} border p-1 cursor-pointer ${dark ? 'hover:bg-slate-700/40' : 'hover:bg-slate-100'} relative" onmousedown="startLongPress(this, openEventModalForTime, ${date.getTime()}, ${hour})" ontouchstart="startLongPress(this, openEventModalForTime, ${date.getTime()}, ${hour})">
                                            ${hourWeather ? `<div class="absolute top-0 right-0 text-[9px] ${dark ? 'text-slate-500' : 'text-slate-400'} flex items-center gap-0.5 pr-0.5">${hourWeather.icon}${hourWeather.temp}¬∞</div>` : ''}
                                            ${dayEvents.map(e => `<div onclick="event.stopPropagation(); showEventDetails(events.find(ev => ev.summary === '${e.summary.replace(/'/g, "\\'")}' && ev.start === '${e.start}'))" class="text-xs px-1 py-0.5 truncate text-white font-medium cursor-pointer hover:opacity-80" style="background-color: ${e.color}">${e.summary}</div>`).join('')}
                                        </div>
                                    `;
                                }).join('')}
                            </div>
                        `).join('')}
                        ${showTimeLine ? `<div id="current-time-line" class="absolute pointer-events-none" style="left: 0; right: 0; height: 2px; background: #ef4444; z-index: 10;">
                            <div class="absolute -left-1 -top-1 w-3 h-3 rounded-full bg-red-500"></div>
                        </div>` : ''}
                    </div>
                </div>
            `;

            // Position the time line (but only scroll on initial view, not on data refresh)
            // Use setTimeout to ensure DOM is fully rendered
            if (showTimeLine) {
                setTimeout(() => updateWeekTimeIndicator(shouldScrollToTime), 50);
            }
        }

        // Update the current time indicator line position
        function updateWeekTimeIndicator(scrollToLine = false) {
            const timeLine = document.getElementById('current-time-line');
            const timeGrid = document.getElementById('week-time-grid');
            if (!timeLine || !timeGrid) return;

            const now = new Date();
            const currentHour = now.getHours();
            const currentMinutes = now.getMinutes();

            // Grid shows full 24 hours (0-23)
            const startHour = 0;

            timeLine.style.display = 'block';

            // Find the hour rows to calculate position
            const hourRows = timeGrid.querySelectorAll('.hour-row');
            if (hourRows.length === 0) return;

            const firstRow = hourRows[0];
            const rowHeight = firstRow.offsetHeight + 4; // Include gap

            // Calculate which row we're in and offset within that row
            const hourIndex = currentHour - startHour;
            const minuteOffset = (currentMinutes / 60) * rowHeight;
            const topPosition = (hourIndex * rowHeight) + minuteOffset;

            timeLine.style.top = `${topPosition}px`;

            // Scroll to show the current time line
            if (scrollToLine) {
                timeLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                shouldScrollToTime = false; // Don't scroll again on data refresh
            }
        }

        // Update time indicator for day view
        function updateDayTimeIndicator(scrollToLine = false) {
            const timeLine = document.getElementById('day-time-line');
            const timeGrid = document.getElementById('day-time-grid');
            if (!timeLine || !timeGrid) return;

            const now = new Date();
            const currentHour = now.getHours();
            const currentMinutes = now.getMinutes();

            // Grid shows full 24 hours (0-23)
            const startHour = 0;

            timeLine.style.display = 'block';

            // Find the hour rows to calculate position
            const hourRows = timeGrid.querySelectorAll('.hour-row');
            if (hourRows.length === 0) return;

            const firstRow = hourRows[0];
            const rowHeight = firstRow.offsetHeight + 4; // Include gap

            // Calculate which row we're in and offset within that row
            const hourIndex = currentHour - startHour;
            const minuteOffset = (currentMinutes / 60) * rowHeight;
            const topPosition = (hourIndex * rowHeight) + minuteOffset;

            timeLine.style.top = `${topPosition}px`;

            // Scroll to show the current time line
            if (scrollToLine) {
                timeLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                shouldScrollToTime = false; // Don't scroll again on data refresh
            }
        }

        function renderDayView(container) {
            const hours = Array.from({ length: 24 }, (_, i) => i); // Full 24 hours
            const today = new Date();
            const isToday = currentDate.toDateString() === today.toDateString();
            const dark = isDarkMode;

            const dateKey = currentDate.getFullYear() + '-' + currentDate.getMonth() + '-' + currentDate.getDate();
            const dayWeather = weatherForecast[dateKey];

            // Get all-day events for this day
            const allDayEvents = events.filter(e => {
                if (!visibleCalendars.has(e.calendar)) return false;
                const eventDate = e.startDate;
                const eventEndDate = e.endDate;
                const isAllDay = eventDate.getHours() === 0 && eventDate.getMinutes() === 0 &&
                                eventEndDate.getHours() === 0 && eventEndDate.getMinutes() === 0;
                if (!isAllDay) return false;
                return eventDate.getDate() === currentDate.getDate() &&
                       eventDate.getMonth() === currentDate.getMonth() &&
                       eventDate.getFullYear() === currentDate.getFullYear();
            });

            container.innerHTML = `
                <div class="h-full flex flex-col">
                    <div class="text-center pb-4 ${dark ? 'border-slate-700/50 bg-slate-800/95' : 'border-slate-200 bg-white/95'} border-b sticky top-0 z-10 backdrop-blur-sm">
                        <div class="flex items-center justify-center gap-2">
                            <span class="${isToday ? 'text-indigo-400' : (dark ? 'text-slate-400' : 'text-slate-500')} text-sm">${currentDate.toLocaleDateString('en-US', { weekday: 'long' })}</span>
                            ${dayWeather ? `<span class="text-xl">${dayWeather.icon}</span>` : ''}
                        </div>
                        <div class="text-4xl font-light ${isToday ? 'text-indigo-400' : (dark ? 'text-white' : 'text-slate-800')} mt-1">${currentDate.getDate()}</div>
                        ${dayWeather ? `<div class="text-sm ${dark ? 'text-slate-400' : 'text-slate-500'} mt-1">High: ${dayWeather.high}¬∞F/${dayWeather.highC}¬∞C ¬∑ Low: ${dayWeather.low}¬∞F/${dayWeather.lowC}¬∞C</div>` : ''}
                    </div>
                    ${allDayEvents.length > 0 ? `
                    <div class="flex gap-4 py-2 border-b ${dark ? 'border-slate-700' : 'border-slate-200'}">
                        <div class="${dark ? 'text-slate-400' : 'text-slate-500'} text-xs w-20 text-right pt-1 flex-shrink-0">All Day</div>
                        <div class="flex-1 flex flex-wrap gap-2">
                            ${allDayEvents.map(e => `<div onclick="showEventDetails(events.find(ev => ev.summary === '${e.summary.replace(/'/g, "\\'")}' && ev.start === '${e.start}'))" class="px-3 py-1 text-white text-sm font-medium cursor-pointer hover:opacity-80 rounded" style="background-color: ${e.color}">${e.summary}</div>`).join('')}
                        </div>
                    </div>
                    ` : ''}
                    <div id="day-time-grid" class="space-y-1 overflow-auto relative flex-1 mt-4">
                        ${hours.map(hour => {
                            const dayEvents = getEventsForDateTime(currentDate, hour, true);
                            const hourWeather = hourlyForecast[dateKey] ? hourlyForecast[dateKey][hour] : null;
                            return `
                                <div class="flex gap-4 min-h-16 hour-row" data-hour="${hour}">
                                    <div class="${dark ? 'text-slate-400' : 'text-slate-500'} text-xs w-20 text-right pt-1 flex-shrink-0">
                                        ${formatHour(hour)}
                                        ${hourWeather ? `<div class="flex items-center justify-end gap-0.5 mt-0.5"><span class="text-[10px]">${hourWeather.icon}</span><span class="text-[10px]">${hourWeather.temp}¬∞/${hourWeather.tempC}¬∞</span></div>` : ''}
                                    </div>
                                    <div class="flex-1 ${dark ? 'bg-slate-700/20 border-slate-700/30 hover:bg-slate-700/40' : 'bg-slate-50 border-slate-200 hover:bg-slate-100'} border p-2 cursor-pointer" onmousedown="startLongPress(this, openEventModalForTime, ${currentDate.getTime()}, ${hour})" ontouchstart="startLongPress(this, openEventModalForTime, ${currentDate.getTime()}, ${hour})">
                                        ${dayEvents.map(e => `
                                            <div onclick="event.stopPropagation(); showEventDetails(events.find(ev => ev.summary === '${e.summary.replace(/'/g, "\\'")}' && ev.start === '${e.start}'))" class="p-2 text-white text-sm mb-1 cursor-pointer hover:opacity-80 transition-opacity" style="background-color: ${e.color}">
                                                <div class="font-medium">${e.summary}</div>
                                                <div class="text-white/70 text-xs">${formatEventTime(e)}</div>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                        ${isToday ? `<div id="day-time-line" class="absolute pointer-events-none" style="left: 0; right: 0; height: 2px; background: #ef4444; z-index: 10;">
                            <div class="absolute -left-1 -top-1 w-3 h-3 rounded-full bg-red-500"></div>
                        </div>` : ''}
                    </div>
                </div>
            `;

            // Position the time line (but only scroll on initial view, not on data refresh)
            // Use setTimeout to ensure DOM is fully rendered
            if (isToday) {
                setTimeout(() => updateDayTimeIndicator(shouldScrollToTime), 50);
            }
        }

        function getEventsForDay(day) {
            return events.filter(e => {
                // Filter by visibility
                if (!visibleCalendars.has(e.calendar)) return false;

                const eventDate = e.startDate;
                return eventDate.getDate() === day &&
                       eventDate.getMonth() === currentDate.getMonth() &&
                       eventDate.getFullYear() === currentDate.getFullYear();
            });
        }

        function getEventsForDateTime(date, hour, startOnly = false) {
            return events.filter(e => {
                // Filter by visibility
                if (!visibleCalendars.has(e.calendar)) return false;

                const eventDate = e.startDate;
                const eventEndDate = e.endDate;
                const eventHour = eventDate.getHours();
                const eventEndHour = eventEndDate.getHours();

                // Check if this is an all-day event (starts at midnight, ends at midnight next day)
                const isAllDay = eventHour === 0 && eventDate.getMinutes() === 0 &&
                                eventEndHour === 0 && eventEndDate.getMinutes() === 0;

                const sameDay = eventDate.getDate() === date.getDate() &&
                               eventDate.getMonth() === date.getMonth() &&
                               eventDate.getFullYear() === date.getFullYear();

                if (!sameDay) return false;

                // All-day events show at the top (hour 0) only
                if (isAllDay) {
                    return hour === 0;
                }

                if (startOnly) {
                    return eventHour === hour;
                }
                return hour >= eventHour && hour < eventEndHour;
            });
        }

        function formatHour(hour) {
            const h = hour > 12 ? hour - 12 : hour === 0 ? 12 : hour;
            const ampm = hour >= 12 ? 'PM' : 'AM';
            return `${h}:00 ${ampm}`;
        }

        function formatEventTime(event) {
            const start = event.startDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const end = event.endDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            return `${start} - ${end}`;
        }

        // Navigation
        function navigateMonth(direction) {
            if (currentView === 'month') {
                currentDate.setMonth(currentDate.getMonth() + direction);
            } else if (currentView === 'week') {
                currentDate.setDate(currentDate.getDate() + (direction * 7));
            } else {
                currentDate.setDate(currentDate.getDate() + direction);
            }
            currentDate = new Date(currentDate);
            loadCalendarEvents();
        }

        function handleDayClick(day, isCurrentMonth) {
            if (isCurrentMonth) {
                currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth(), day);
                setView('day');
            }
        }

        function goToDay(timestamp) {
            currentDate = new Date(timestamp);
            setView('day');
        }

        // Views
        function setView(view) {
            currentView = view;
            localStorage.setItem('currentView', view);
            ['month', 'week', 'day'].forEach(v => {
                const btn = document.getElementById(`view-${v}`);
                if (v === view) {
                    btn.className = 'view-btn px-5 py-2 text-sm font-medium bg-indigo-600 text-white';
                } else {
                    btn.className = 'view-btn px-5 py-2 text-sm font-medium text-slate-400 hover:text-white hover:bg-slate-700/50';
                }
            });
            // Scroll to current time when switching to week/day view
            shouldScrollToTime = (view === 'week' || view === 'day');
            renderCalendar();
        }

        // Tabs
        function setActiveTab(tab) {
            activeTab = tab;
            localStorage.setItem('activeTab', tab);
            ['calendar', 'todos', 'controls'].forEach(t => {
                const tabEl = document.getElementById(`tab-${t}`);
                const btnEl = document.getElementById(`btn-${t}`);

                if (t === tab) {
                    tabEl.classList.remove('hidden');
                    btnEl.className = 'sidebar-btn w-14 h-14 flex items-center justify-center bg-indigo-600 text-white';
                } else {
                    tabEl.classList.add('hidden');
                    btnEl.className = 'sidebar-btn w-14 h-14 flex items-center justify-center bg-slate-800/50 hover:bg-slate-700/50 text-slate-400 hover:text-white';
                }
            });

            // Notify MQTT bridge of tab change
            if (mqttBridge) mqttBridge.notifyStateChange();
        }

        // Event Modal
        function formatLocalDate(d) {
            const year = d.getFullYear();
            const month = String(d.getMonth() + 1).padStart(2, '0');
            const day = String(d.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        // Populate calendar dropdown with available calendars
        function populateCalendarDropdown() {
            const select = document.getElementById('eventCalendar');
            select.innerHTML = availableCalendars.map(cal =>
                `<option value="${cal.entity_id}">${cal.name}</option>`
            ).join('');
        }

        // Long-press handler for creating events (2 second hold)
        let longPressTimer = null;
        let longPressTarget = null;
        const LONG_PRESS_DURATION = 2000; // 2 seconds

        function startLongPress(element, callback, ...args) {
            longPressTarget = element;
            element.style.transition = 'transform 0.2s, box-shadow 0.2s';
            element.style.transform = 'scale(0.98)';
            element.style.boxShadow = 'inset 0 0 20px rgba(99, 102, 241, 0.3)';
            
            // Prevent context menu on this element during long-press
            element._contextMenuHandler = (e) => e.preventDefault();
            element.addEventListener('contextmenu', element._contextMenuHandler);
            
            longPressTimer = setTimeout(() => {
                element.style.transform = '';
                element.style.boxShadow = '';
                callback(...args);
                longPressTimer = null;
                longPressTarget = null;
            }, LONG_PRESS_DURATION);
        }

        function cancelLongPress() {
            if (longPressTimer) {
                clearTimeout(longPressTimer);
                longPressTimer = null;
            }
            if (longPressTarget) {
                longPressTarget.style.transform = '';
                longPressTarget.style.boxShadow = '';
                // Clean up context menu handler
                if (longPressTarget._contextMenuHandler) {
                    longPressTarget.removeEventListener('contextmenu', longPressTarget._contextMenuHandler);
                    delete longPressTarget._contextMenuHandler;
                }
                longPressTarget = null;
            }
        }

        // Add global listeners to cancel long-press on mouse/touch release or move
        document.addEventListener('mouseup', cancelLongPress);
        document.addEventListener('mouseleave', cancelLongPress);
        document.addEventListener('touchend', cancelLongPress);
        document.addEventListener('touchcancel', cancelLongPress);

        function openEventModal() {
            populateCalendarDropdown();
            const dateStr = formatLocalDate(currentDate);
            console.log('Opening modal with date:', dateStr);
            document.getElementById('eventDate').value = dateStr;
            document.getElementById('eventStartTime').value = '09:00';
            document.getElementById('eventEndTime').value = '10:00';
            document.getElementById('eventTitle').value = '';
            document.getElementById('createEventBtn').disabled = false;
            document.getElementById('createEventBtn').textContent = 'Create Event';
            document.getElementById('eventModal').classList.remove('hidden');
        }

        function openEventModalForTime(timestamp, hour) {
            populateCalendarDropdown();
            const date = new Date(timestamp);
            const dateStr = formatLocalDate(date);
            console.log('Opening modal for time with date:', dateStr, 'hour:', hour);
            document.getElementById('eventDate').value = dateStr;
            document.getElementById('eventStartTime').value = `${hour.toString().padStart(2, '0')}:00`;
            document.getElementById('eventEndTime').value = `${(hour + 1).toString().padStart(2, '0')}:00`;
            document.getElementById('eventTitle').value = '';
            document.getElementById('createEventBtn').disabled = false;
            document.getElementById('createEventBtn').textContent = 'Create Event';
            document.getElementById('eventModal').classList.remove('hidden');
        }

        function closeEventModal() {
            document.getElementById('eventModal').classList.add('hidden');

            // Reset form fields
            document.getElementById('eventTitle').value = '';
            document.getElementById('eventRecurring').checked = false;
            document.getElementById('recurringOptions').classList.add('hidden');
            document.getElementById('eventRecurrenceType').value = 'weekly';
            document.getElementById('eventRecurrenceEndType').value = 'occurrences';
            document.getElementById('eventRecurrenceOccurrences').value = '10';
            document.getElementById('recurrenceOccurrencesDiv').classList.remove('hidden');
            document.getElementById('recurrenceEndDateDiv').classList.add('hidden');
        }

        // Event Details Modal Functions
        let currentEventDetails = null;

        function isRecurringEvent(event) {
            // Check if event has RRULE (native recurring event)
            return event.rrule && event.rrule.length > 0;
        }

        function getRecurringEventId(event) {
            // For RRULE events, use the UID which is common to all instances
            return event.uid || event.recurrence_id || null;
        }

        async function showEventDetails(event) {
            currentEventDetails = event;
            const isPartOfSeries = isRecurringEvent(event);

            const modal = document.getElementById('eventDetailsModal');
            const content = document.getElementById('eventDetailsContent');

            const startTime = event.startDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const endTime = event.endDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const dateStr = event.startDate.toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });

            // Parse RRULE to get human-readable recurrence info
            let recurrenceInfo = '';
            if (isPartOfSeries && event.rrule) {
                recurrenceInfo = parseRRule(event.rrule);
            }

            content.innerHTML = `
                <div class="space-y-4">
                    <div>
                        <div class="inline-block px-3 py-1 text-xs font-medium text-white mb-3" style="background-color: ${event.color}">
                            ${event.calendar.split('.')[1].toUpperCase()}
                        </div>
                        <h4 class="text-2xl font-semibold text-white">${event.summary}</h4>
                    </div>

                    <div class="space-y-2 text-sm">
                        <div class="flex items-center gap-2 text-slate-300">
                            <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z"/></path></svg>
                            <span>${dateStr}</span>
                        </div>
                        <div class="flex items-center gap-2 text-slate-300">
                            <svg class="w-5 h-5 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"/></path></svg>
                            <span>${startTime} - ${endTime}</span>
                        </div>
                        ${isPartOfSeries ? `
                            <div class="flex items-center gap-2 text-indigo-400">
                                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/></path></svg>
                                <span>Recurring: ${recurrenceInfo}</span>
                            </div>
                        ` : ''}
                    </div>

                    <div class="border-t border-slate-700 pt-4 space-y-2">
                        ${isPartOfSeries ? `
                            <button onclick="deleteEvent(false)" class="w-full py-3 bg-red-600/20 hover:bg-red-600/30 text-red-400 font-medium border border-red-600/30">
                                Delete This Occurrence Only
                            </button>
                            <button onclick="deleteEvent(true)" class="w-full py-3 bg-red-600 hover:bg-red-700 text-white font-medium">
                                Delete Entire Series
                            </button>
                        ` : `
                            <button onclick="deleteEvent(false)" class="w-full py-3 bg-red-600 hover:bg-red-700 text-white font-medium">
                                Delete Event
                            </button>
                        `}
                        <button onclick="closeEventDetailsModal()" class="w-full py-3 bg-slate-700 hover:bg-slate-600 text-white font-medium">
                            Close
                        </button>
                    </div>
                </div>
            `;

            modal.classList.remove('hidden');
        }

        function parseRRule(rrule) {
            // Parse RRULE to human-readable format
            if (!rrule) return '';

            const parts = rrule.replace('RRULE:', '').split(';');
            let freq = '', interval = '', count = '', until = '';

            parts.forEach(part => {
                const [key, value] = part.split('=');
                if (key === 'FREQ') {
                    freq = value.toLowerCase();
                } else if (key === 'INTERVAL') {
                    interval = value;
                } else if (key === 'COUNT') {
                    count = value;
                } else if (key === 'UNTIL') {
                    until = value;
                }
            });

            let text = '';
            if (freq === 'DAILY') text = 'Daily';
            else if (freq === 'WEEKLY') {
                text = interval === '2' ? 'Every 2 weeks' : 'Weekly';
            }
            else if (freq === 'MONTHLY') text = 'Monthly';

            if (count) text += `, ${count} times`;
            else if (until) {
                const year = until.substring(0, 4);
                const month = until.substring(4, 6);
                const day = until.substring(6, 8);
                text += ` until ${month}/${day}/${year}`;
            }

            return text;
        }

        function closeEventDetailsModal() {
            document.getElementById('eventDetailsModal').classList.add('hidden');
            currentEventDetails = null;
        }

        async function deleteEvent(deleteSeries) {
            if (!currentEventDetails) return;

            const isRecurring = isRecurringEvent(currentEventDetails);
            const confirmMsg = (deleteSeries && isRecurring)
                ? 'Delete the entire recurring series?'
                : isRecurring
                    ? 'Delete only this occurrence?'
                    : 'Delete this event?';

            if (!confirm(confirmMsg)) return;

            try {
                const payload = {
                    entity_id: currentEventDetails.calendar,
                    uid: currentEventDetails.uid
                };

                // For recurring events
                if (isRecurring && !deleteSeries) {
                    // Delete only this occurrence by specifying the recurrence_id
                    payload.recurrence_id = currentEventDetails.start;
                    payload.recurrence_range = 'THIS';
                } else if (isRecurring && deleteSeries) {
                    // Delete entire series
                    payload.recurrence_range = 'ALL';
                }

                console.log('Deleting event with payload:', payload);

                const response = await fetch(`/api/services/calendar/delete_event`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                closeEventDetailsModal();
                await loadCalendarEvents();

                alert((deleteSeries && isRecurring) ? 'Successfully deleted entire series' : 'Event deleted successfully');

            } catch (e) {
                console.error('Delete event error:', e);
                alert('Failed to delete event: ' + e.message + '\n\nNote: You may need to delete this event through the Home Assistant UI or your calendar provider (Google Calendar, etc.)');
            }
        }


        function toggleRecurringOptions() {
            const checkbox = document.getElementById('eventRecurring');
            const options = document.getElementById('recurringOptions');
            options.classList.toggle('hidden', !checkbox.checked);
        }

        function toggleRecurrenceEndType() {
            const endType = document.getElementById('eventRecurrenceEndType').value;
            const occurrencesDiv = document.getElementById('recurrenceOccurrencesDiv');
            const endDateDiv = document.getElementById('recurrenceEndDateDiv');

            if (endType === 'occurrences') {
                occurrencesDiv.classList.remove('hidden');
                endDateDiv.classList.add('hidden');
            } else {
                occurrencesDiv.classList.add('hidden');
                endDateDiv.classList.remove('hidden');
            }
        }

        function generateRRule(startDate, recurrenceType, endType, occurrences, endDate) {
            // Generate RRULE (RFC 5545) for native recurring events
            let rrule = 'RRULE:';

            switch (recurrenceType) {
                case 'daily':
                    rrule += 'FREQ=DAILY';
                    break;
                case 'weekly':
                    rrule += 'FREQ=WEEKLY';
                    break;
                case 'biweekly':
                    rrule += 'FREQ=WEEKLY;INTERVAL=2';
                    break;
                case 'monthly':
                    rrule += 'FREQ=MONTHLY';
                    break;
            }

            if (endType === 'occurrences') {
                rrule += `;COUNT=${occurrences}`;
            } else if (endType === 'date') {
                // Format: YYYYMMDD
                const endDateObj = new Date(endDate);
                const year = endDateObj.getFullYear();
                const month = String(endDateObj.getMonth() + 1).padStart(2, '0');
                const day = String(endDateObj.getDate()).padStart(2, '0');
                rrule += `;UNTIL=${year}${month}${day}T235959Z`;
            }

            return rrule;
        }

        async function submitNewEvent() {
            console.log('submitNewEvent called');

            const title = document.getElementById('eventTitle').value.trim();
            const calendar = document.getElementById('eventCalendar').value;
            const date = document.getElementById('eventDate').value;
            const startTime = document.getElementById('eventStartTime').value;
            const endTime = document.getElementById('eventEndTime').value;
            const isRecurring = document.getElementById('eventRecurring').checked;

            console.log('Form values:', { title, calendar, date, startTime, endTime, isRecurring });

            if (!title) {
                alert('Please enter an event title');
                return;
            }

            if (!date || !startTime || !endTime) {
                alert('Please fill in all fields');
                return;
            }

            const createBtn = document.getElementById('createEventBtn');
            createBtn.disabled = true;
            createBtn.textContent = 'Creating...';

            try {
                // Build the event payload
                const payload = {
                    entity_id: calendar,
                    summary: title,
                    start_date_time: `${date}T${startTime}:00`,
                    end_date_time: `${date}T${endTime}:00`
                };

                // Handle recurring events with RRULE
                if (isRecurring) {
                    const recurrenceType = document.getElementById('eventRecurrenceType').value;
                    const endType = document.getElementById('eventRecurrenceEndType').value;
                    const occurrences = parseInt(document.getElementById('eventRecurrenceOccurrences').value);
                    const endDate = document.getElementById('eventRecurrenceEndDate').value;

                    // Generate RRULE string
                    const rrule = generateRRule(date, recurrenceType, endType, occurrences, endDate);
                    payload.rrule = rrule;

                    createBtn.textContent = 'Creating recurring event...';
                    console.log('Creating recurring event with RRULE:', rrule);
                } else {
                    createBtn.textContent = 'Creating event...';
                }

                // Create the event
                const response = await fetch('/api/services/calendar/create_event', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                console.log('Response status:', response.status);

                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Error response:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }

                const result = await response.text();
                console.log('Response body:', result);

                closeEventModal();

                // Navigate to the date of the event
                currentDate = new Date(date + 'T12:00:00');

                // Reload calendar events
                await loadCalendarEvents();

                console.log('Event created successfully');

                if (isRecurring) {
                    alert('Successfully created recurring event!');
                }

            } catch (e) {
                console.error('Create event error:', e);
                alert('Failed to create event: ' + e.message);
            } finally {
                createBtn.disabled = false;
                createBtn.textContent = 'Create Event';
            }
        }

        // Refresh
        async function refreshData() {
            const btn = document.getElementById('refresh-btn');
            const svg = btn.querySelector('svg');
            svg.classList.add('loading-spin');

            try {
                // Priority 1: Calendar events (most important, load and render immediately)
                console.log('Refresh: Loading calendar events...');
                const oldEventKeys = new Set(events.map(e => `${e.summary}|${e.start}`));
                await loadCalendarEvents();
                console.log(`Refresh: Loaded ${events.length} events (was ${oldEventKeys.size})`);
                renderCalendar();
                
                // Announce any new events added since last refresh
                for (const event of events) {
                    const eventKey = `${event.summary}|${event.start}`;
                    if (!oldEventKeys.has(eventKey)) {
                        // New event found - announce it
                        const eventStart = new Date(event.start);
                        const hoursUntilEvent = (eventStart - new Date()) / (1000 * 60 * 60);
                        // Only announce events within the next 7 days
                        if (hoursUntilEvent > -1 && hoursUntilEvent < 168) {
                            console.log('New event detected on refresh:', event.summary);
                            announceNewItem('calendar', event.summary);
                            break; // Only announce one at a time
                        }
                    }
                }
                
                // Priority 2: Notifications (load in background, don't wait)
                loadMailNotifications().catch(e => console.error('Notification refresh error:', e));
                
                // Priority 3: Everything else in parallel (don't block UI)
                Promise.all([
                    loadWeather(),
                    loadTodos(),
                    loadAvailableCalendars(),
                    loadAvailableTodoLists()
                ]).catch(e => console.error('Background refresh error:', e));
                
            } catch (e) {
                console.error('Refresh error:', e);
            }
            
            // Remove spinner after calendar is loaded (don't wait for everything)
            svg.classList.remove('loading-spin');
        }

        // Event Alert System
        function checkUpcomingEvents() {
            const now = new Date();

            // Check calendar events
            for (const event of events) {
                const eventStart = event.startDate;
                const eventId = `${event.summary}-${eventStart.getTime()}`;

                // Skip if already alerted and not snoozed
                if (alertedEvents.has(eventId) && !snoozedEvents[eventId]) {
                    continue;
                }

                // Check if snoozed and snooze time hasn't passed yet
                if (snoozedEvents[eventId] && now < snoozedEvents[eventId]) {
                    continue;
                }

                // Calculate minutes until event
                const minutesUntil = (eventStart - now) / (1000 * 60);

                // Alert if event is within ALERT_MINUTES_BEFORE minutes and hasn't started yet
                if (minutesUntil > 0 && minutesUntil <= ALERT_MINUTES_BEFORE) {
                    showEventAlert(event, minutesUntil);
                    alertedEvents.add(eventId);
                    delete snoozedEvents[eventId]; // Clear snooze if was snoozed
                    return; // Only show one alert at a time
                }

                // Also alert if snoozed event's snooze time has passed
                if (snoozedEvents[eventId] && now >= snoozedEvents[eventId]) {
                    showEventAlert(event, minutesUntil);
                    delete snoozedEvents[eventId];
                    return;
                }
            }

            // Check prayer times
            const prayerNames = {
                fajr: 'Fajr Prayer',
                dhuhr: 'Dhuhr Prayer',
                asr: 'Asr Prayer',
                maghrib: 'Maghrib Prayer',
                isha: 'Isha Prayer'
            };

            for (const [prayer, time] of Object.entries(prayerTimes)) {
                if (!time) continue;

                const prayerId = `prayer-${prayer}-${time.toDateString()}`;

                // Skip if already alerted and not snoozed
                if (alertedEvents.has(prayerId) && !snoozedEvents[prayerId]) {
                    continue;
                }

                // Check if snoozed and snooze time hasn't passed yet
                if (snoozedEvents[prayerId] && now < snoozedEvents[prayerId]) {
                    continue;
                }

                const minutesUntil = (time - now) / (1000 * 60);

                // Alert if prayer is within ALERT_MINUTES_BEFORE minutes
                if (minutesUntil > 0 && minutesUntil <= ALERT_MINUTES_BEFORE) {
                    // Show gentle prayer notification (no alarm sound)
                    showPrayerNotification(prayer, prayerNames[prayer], time);
                    alertedEvents.add(prayerId);
                    delete snoozedEvents[prayerId];
                    return;
                }

                // Also alert if snoozed prayer's snooze time has passed
                if (snoozedEvents[prayerId] && now >= snoozedEvents[prayerId]) {
                    // Show gentle prayer notification (no alarm sound)
                    showPrayerNotification(prayer, prayerNames[prayer], time);
                    delete snoozedEvents[prayerId];
                    return;
                }
            }
        }

        function showEventAlert(event, minutesUntil, isPrayer = false) {
            // Wake screensaver before showing alert
            if (screensaverController?.isActive) {
                screensaverController.wake('alarm');
            }

            currentAlertEvent = event;

            const modal = document.getElementById('alertModal');
            const title = document.getElementById('alert-title');
            const time = document.getElementById('alert-time');
            const details = document.getElementById('alert-details');
            const iconEl = document.querySelector('#alertModal .animate-bounce');
            const labelEl = document.querySelector('#alertModal .text-indigo-400');

            // Update icon and label based on event type
            if (isPrayer || event.isPrayer) {
                iconEl.textContent = 'üïå';
                labelEl.textContent = 'Prayer Time';
            } else {
                iconEl.textContent = 'üîî';
                labelEl.textContent = 'Upcoming Event';
            }

            title.textContent = event.summary;

            const startTime = event.startDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            const endTime = event.endDate.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });

            if (minutesUntil <= 0) {
                time.textContent = isPrayer ? 'Time for prayer!' : 'Starting now!';
            } else if (minutesUntil < 1) {
                time.textContent = 'Starting in less than a minute!';
            } else {
                time.textContent = `Starting in ${Math.round(minutesUntil)} minute${Math.round(minutesUntil) === 1 ? '' : 's'}`;
            }

            if (isPrayer || event.isPrayer) {
                details.textContent = `Prayer time: ${startTime}`;
            } else {
                details.textContent = `${startTime} - ${endTime}`;
            }

            modal.classList.remove('hidden');

            // Initialize volume slider with saved value
            initVolumeSlider();

            // Start looping alarm sound
            startAlarmLoop();

            // Auto-dismiss after 5 minutes
            if (autoDismissTimer) {
                clearTimeout(autoDismissTimer);
            }
            autoDismissTimer = setTimeout(() => {
                console.log('Auto-dismissing alarm after 5 minutes');
                dismissAlert();
            }, AUTO_DISMISS_MS);

            // Announce the event using TTS
            let announcement;
            if (isPrayer || event.isPrayer) {
                announcement = `Time for ${event.summary} prayer`;
            } else if (minutesUntil <= 0) {
                announcement = `${event.summary} is starting now`;
            } else {
                announcement = `${event.summary} starts in ${Math.round(minutesUntil)} minutes`;
            }
            speakText(announcement);

            // Request browser notification permission and show notification
            if ('Notification' in window && Notification.permission === 'granted') {
                new Notification(event.summary, {
                    body: isPrayer ? `Prayer time: ${startTime}` : `Starts at ${startTime}`,
                    icon: isPrayer ? 'üïå' : 'üìÖ'
                });
            } else if ('Notification' in window && Notification.permission !== 'denied') {
                Notification.requestPermission();
            }
        }

        function snoozeAlert(minutes) {
            // Stop the alarm and TTS
            stopAlarm();

            // Clear auto-dismiss timer
            if (autoDismissTimer) {
                clearTimeout(autoDismissTimer);
                autoDismissTimer = null;
            }

            if (currentAlertEvent) {
                const eventId = currentAlertEvent.prayerId || `${currentAlertEvent.summary}-${currentAlertEvent.startDate.getTime()}`;
                const snoozeUntil = new Date(Date.now() + minutes * 60 * 1000);
                snoozedEvents[eventId] = snoozeUntil;
                alertedEvents.delete(eventId); // Allow re-alerting after snooze

                console.log(`Snoozed "${currentAlertEvent.summary}" for ${minutes} minutes until ${snoozeUntil.toLocaleTimeString()}`);

                // Announce snooze
                speakText(`Snoozed for ${minutes} minutes`);
            }
            closeAlertModal();
        }

        function dismissAlert() {
            // Stop the alarm and TTS
            stopAlarm();

            // Clear auto-dismiss timer
            if (autoDismissTimer) {
                clearTimeout(autoDismissTimer);
                autoDismissTimer = null;
            }

            if (currentAlertEvent) {
                const eventId = currentAlertEvent.prayerId || `${currentAlertEvent.summary}-${currentAlertEvent.startDate.getTime()}`;
                alertedEvents.add(eventId); // Mark as dismissed
                delete snoozedEvents[eventId];

                console.log(`Dismissed "${currentAlertEvent.summary}"`);
            }
            closeAlertModal();
        }

        function closeAlertModal() {
            document.getElementById('alertModal').classList.add('hidden');
            currentAlertEvent = null;

            // Reset idle detector so screensaver can restart after timeout
            if (idleDetector && idleDetector.running) {
                idleDetector.resetTimer();
                console.log('Idle timer reset after alert dismiss');
            }
        }

        // ==================== PRAYER NOTIFICATION (NO ALARM) ====================
        let prayerNotificationTimer = null;

        function showPrayerNotification(prayerKey, prayerName, prayerTime) {
            // Wake screensaver before showing notification
            if (screensaverController?.isActive) {
                screensaverController.wake('prayer');
            }

            const notification = document.getElementById('prayerNotification');
            const textEl = document.getElementById('prayer-notification-text');
            const timeEl = document.getElementById('prayer-notification-time');

            // Format the prayer name (remove "Prayer" suffix if present)
            const displayName = prayerName.replace(' Prayer', '');
            textEl.textContent = `Get ready, time for ${displayName}`;

            const timeStr = prayerTime.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit', hour12: true });
            timeEl.textContent = timeStr;

            notification.classList.remove('hidden');

            // Speak the announcement (no alarm sound)
            speakText(`Get ready, time for ${displayName}`);

            // Auto-dismiss after 30 seconds
            if (prayerNotificationTimer) {
                clearTimeout(prayerNotificationTimer);
            }
            prayerNotificationTimer = setTimeout(() => {
                closePrayerNotification();
            }, 30000);

            console.log(`Prayer notification: ${prayerName} at ${timeStr}`);
        }

        function closePrayerNotification() {
            document.getElementById('prayerNotification').classList.add('hidden');
            if (prayerNotificationTimer) {
                clearTimeout(prayerNotificationTimer);
                prayerNotificationTimer = null;
            }
        }

        // ==================== SCREENSAVER SYSTEM ====================

        // Screensaver Settings
        const DEFAULT_SCREENSAVER_SETTINGS = {
            enabled: true,
            idleTimeout: 5 * 60 * 1000, // 5 minutes
            slideInterval: 10 * 1000,   // 10 seconds
            transitionDuration: 1500,    // 1.5 seconds
            kenBurnsEnabled: true,
            showMetadata: true,
            hourlyChimeEnabled: false,
            hourlyChimeCallout: true,
            hourlyChimeStart: 6,
            hourlyChimeEnd: 22,
            providerType: 'local',
            providerConfig: {
                folderPath: '',
                shareLink: ''
            }
        };

        let screensaverSettings = { ...DEFAULT_SCREENSAVER_SETTINGS };
        let screensaverController = null;
        let idleDetector = null;

        // Load settings from localStorage
        function loadScreensaverSettings() {
            try {
                const saved = localStorage.getItem('screensaverSettings');
                if (saved) {
                    screensaverSettings = { ...DEFAULT_SCREENSAVER_SETTINGS, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.error('Error loading screensaver settings:', e);
            }
        }

        // Save settings to localStorage
        function saveScreensaverSettings() {
            try {
                localStorage.setItem('screensaverSettings', JSON.stringify(screensaverSettings));
            } catch (e) {
                console.error('Error saving screensaver settings:', e);
            }
        }

        // Update a single setting
        function updateScreensaverSetting(key, value) {
            screensaverSettings[key] = value;
            saveScreensaverSettings();

            // Apply changes immediately if applicable
            if (key === 'enabled') {
                if (value && idleDetector) {
                    idleDetector.start();
                } else if (!value && idleDetector) {
                    idleDetector.stop();
                    if (screensaverController?.isActive) {
                        screensaverController.wake('settings');
                    }
                }
            } else if (key === 'idleTimeout' && idleDetector) {
                idleDetector.timeout = value;
            } else if (key === 'slideInterval' && screensaverController) {
                screensaverController.slideInterval = value;
            }

            console.log(`Screensaver setting updated: ${key} = ${value}`);
        }

        // Update Synology config
        function updateSynologyConfig() {
            const shareLink = document.getElementById('ss-synology-share')?.value || '';
            screensaverSettings.providerConfig.shareLink = shareLink;
            saveScreensaverSettings();
        }

        // Update Local folder config
        function updateLocalConfig() {
            const folderPath = document.getElementById('ss-local-path')?.value || '';
            screensaverSettings.providerConfig.folderPath = folderPath;
            saveScreensaverSettings();
        }

        // Toggle provider config visibility
        function toggleProviderConfig(provider) {
            const synologyConfig = document.getElementById('synology-config');
            const localConfig = document.getElementById('local-config');

            if (synologyConfig) {
                synologyConfig.classList.toggle('hidden', provider !== 'synology');
            }
            if (localConfig) {
                localConfig.classList.toggle('hidden', provider !== 'local');
            }
        }

        // Test local folder connection
        async function testLocalConnection() {
            const statusEl = document.getElementById('ss-local-status');
            statusEl.classList.remove('hidden');
            statusEl.className = 'text-sm text-yellow-400';
            statusEl.textContent = 'Testing connection...';

            updateLocalConfig();

            const folderPath = screensaverSettings.providerConfig.folderPath;
            if (!folderPath) {
                statusEl.className = 'text-sm text-red-400';
                statusEl.textContent = 'Please enter a folder path.';
                return;
            }

            try {
                const response = await fetch(`/api/local/photos?path=${encodeURIComponent(folderPath)}`);
                const data = await response.json();

                if (data.success && data.photos) {
                    statusEl.className = 'text-sm text-green-400';
                    statusEl.textContent = `Success! Found ${data.photos.length} photos.`;
                } else {
                    statusEl.className = 'text-sm text-red-400';
                    statusEl.textContent = data.error || 'Folder not found or no images.';
                }
            } catch (e) {
                statusEl.className = 'text-sm text-red-400';
                statusEl.textContent = 'Connection failed: ' + e.message;
            }
        }

        // Flag to prevent background refreshes from waking screensaver
        let isBackgroundRefresh = false;
        
        // Idle Detector Class
        class IdleDetector {
            constructor(options = {}) {
                this.timeout = options.timeout || 5 * 60 * 1000;
                this.onIdle = options.onIdle || (() => {});
                this.onActive = options.onActive || (() => {});
                this.isIdle = false;
                this.timer = null;
                this.events = ['mousedown', 'mousemove', 'click', 'keydown', 'keyup', 'touchstart', 'touchmove', 'scroll'];
                this.handleActivity = this.handleActivity.bind(this);
                this.running = false;
            }

            start() {
                if (this.running) return;
                this.running = true;
                this.events.forEach(event => {
                    document.addEventListener(event, this.handleActivity, { passive: true });
                });
                this.resetTimer();
                console.log('IdleDetector started with timeout:', this.timeout);
            }

            stop() {
                this.running = false;
                this.events.forEach(event => {
                    document.removeEventListener(event, this.handleActivity);
                });
                if (this.timer) {
                    clearTimeout(this.timer);
                    this.timer = null;
                }
            }

            handleActivity() {
                // Ignore activity during background refreshes
                if (isBackgroundRefresh) return;
                
                if (this.isIdle) {
                    this.isIdle = false;
                    this.onActive();
                }
                this.resetTimer();
            }

            resetTimer() {
                if (this.timer) {
                    clearTimeout(this.timer);
                }
                this.timer = setTimeout(() => {
                    this.isIdle = true;
                    this.onIdle();
                }, this.timeout);
            }
        }

        // Photo Provider Base Class
        class PhotoProvider {
            constructor(config = {}) {
                this.config = config;
                this.photos = [];
                this.lastFetch = null;
                this.cacheTimeout = 30 * 60 * 1000; // 30 minutes
            }

            async authenticate() {
                return true;
            }

            async getPhotos() {
                return [];
            }

            getPhotoUrl(photo, size = 'xl') {
                return '';
            }

            needsRefresh() {
                return !this.lastFetch || (Date.now() - this.lastFetch > this.cacheTimeout);
            }
        }

        // Local Folder Provider - serves photos from a local directory
        class LocalFolderProvider extends PhotoProvider {
            constructor(config = {}) {
                super(config);
                this.folderPath = config.folderPath || '';
            }

            async authenticate() {
                return !!this.folderPath;
            }

            async getPhotos() {
                if (!this.folderPath) {
                    console.error('Local Folder: No folder path configured');
                    return [];
                }

                if (!this.needsRefresh() && this.photos.length > 0) {
                    return this.shuffleArray([...this.photos]);
                }

                try {
                    const response = await fetch(`/api/local/photos?path=${encodeURIComponent(this.folderPath)}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    if (data.success && data.photos) {
                        this.photos = data.photos.map(photo => ({
                            id: photo.name,
                            filename: photo.name,
                            path: photo.path,
                            time: photo.mtime ? new Date(photo.mtime * 1000) : null
                        }));
                        this.lastFetch = Date.now();
                        console.log(`Local Folder: Loaded ${this.photos.length} photos`);
                    }

                    return this.shuffleArray([...this.photos]);
                } catch (e) {
                    console.error('Error fetching local photos:', e);
                    return this.shuffleArray([...this.photos]);
                }
            }

            getPhotoUrl(photo) {
                if (!photo || !photo.path) return '';
                return `/api/local/image?path=${encodeURIComponent(photo.path)}`;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        // Synology Photos Provider
        class SynologyPhotosProvider extends PhotoProvider {
            constructor(config = {}) {
                super(config);
                this.baseUrl = '';
                this.passphrase = '';
                this.parseShareLink();
            }

            parseShareLink() {
                const shareLink = this.config.shareLink || '';
                if (!shareLink) return;

                try {
                    const url = new URL(shareLink);
                    this.baseUrl = `${url.protocol}//${url.host}`;
                    // Extract passphrase from path (e.g., /mo/sharing/rkvf2tdz6)
                    const pathMatch = shareLink.match(/\/sharing\/([a-zA-Z0-9]+)/);
                    if (pathMatch) {
                        this.passphrase = pathMatch[1];
                    }
                } catch (e) {
                    console.error('Error parsing Synology share link:', e);
                }
            }

            async authenticate() {
                return this.passphrase && this.baseUrl;
            }

            async getPhotos() {
                if (!this.passphrase || !this.baseUrl) {
                    console.error('Synology Photos: Missing passphrase or base URL');
                    return [];
                }

                if (!this.needsRefresh() && this.photos.length > 0) {
                    return this.shuffleArray([...this.photos]);
                }

                try {
                    // Fetch photos from shared album via proxy
                    const apiUrl = `/api/synology/photos?passphrase=${encodeURIComponent(this.passphrase)}&baseUrl=${encodeURIComponent(this.baseUrl)}`;
                    const response = await fetch(apiUrl);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    const data = await response.json();

                    if (data.success && data.data && data.data.list) {
                        this.photos = data.data.list.map(item => ({
                            id: item.id,
                            filename: item.filename,
                            time: item.time ? new Date(item.time * 1000) : null,
                            type: item.type,
                            additional: item.additional || {}
                        }));
                        this.lastFetch = Date.now();
                        console.log(`Synology Photos: Loaded ${this.photos.length} photos`);
                    }

                    return this.shuffleArray([...this.photos]);
                } catch (e) {
                    console.error('Error fetching Synology photos:', e);
                    // Return cached photos if available
                    return this.shuffleArray([...this.photos]);
                }
            }

            getPhotoUrl(photo, size = 'xl') {
                if (!photo || !photo.id) return '';
                return `/api/synology/thumbnail?id=${photo.id}&size=${size}&passphrase=${encodeURIComponent(this.passphrase)}&baseUrl=${encodeURIComponent(this.baseUrl)}`;
            }

            shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }
        }

        // Photo Queue for preloading
        class PhotoQueue {
            constructor(provider, preloadCount = 5) {
                this.provider = provider;
                this.preloadCount = preloadCount;
                this.photos = [];
                this.currentIndex = -1;
                this.preloadedImages = new Map();
            }

            async initialize() {
                this.photos = await this.provider.getPhotos();
                this.currentIndex = -1;
                this.preloadedImages.clear();

                if (this.photos.length > 0) {
                    await this.preloadNext();
                }

                return this.photos.length > 0;
            }

            async preloadNext() {
                const toPreload = [];
                for (let i = 1; i <= this.preloadCount; i++) {
                    const idx = (this.currentIndex + i) % this.photos.length;
                    if (idx >= 0 && idx < this.photos.length && !this.preloadedImages.has(idx)) {
                        toPreload.push(idx);
                    }
                }

                for (const idx of toPreload) {
                    const photo = this.photos[idx];
                    const url = this.provider.getPhotoUrl(photo);
                    if (url) {
                        const img = new Image();
                        img.src = url;
                        this.preloadedImages.set(idx, img);
                    }
                }

                // Clean up old preloaded images
                for (const idx of this.preloadedImages.keys()) {
                    if (idx < this.currentIndex - 2 || idx > this.currentIndex + this.preloadCount + 2) {
                        this.preloadedImages.delete(idx);
                    }
                }
            }

            next() {
                if (this.photos.length === 0) return null;
                this.currentIndex = (this.currentIndex + 1) % this.photos.length;
                this.preloadNext();
                return this.photos[this.currentIndex];
            }

            previous() {
                if (this.photos.length === 0) return null;
                this.currentIndex = (this.currentIndex - 1 + this.photos.length) % this.photos.length;
                return this.photos[this.currentIndex];
            }

            current() {
                if (this.photos.length === 0 || this.currentIndex < 0) return null;
                return this.photos[this.currentIndex];
            }

            getUrl(photo) {
                return this.provider.getPhotoUrl(photo);
            }

            async refresh() {
                this.photos = await this.provider.getPhotos();
                if (this.currentIndex >= this.photos.length) {
                    this.currentIndex = 0;
                }
            }
        }

        // Image Brightness Detection for Overlay Contrast
        function analyzeImageBrightness(imageUrl, callback) {
            const img = new Image();
            img.crossOrigin = 'Anonymous';
            
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Sample a smaller version for performance
                const sampleSize = 100;
                canvas.width = sampleSize;
                canvas.height = sampleSize;
                
                ctx.drawImage(img, 0, 0, sampleSize, sampleSize);
                
                try {
                    const imageData = ctx.getImageData(0, 0, sampleSize, sampleSize);
                    const data = imageData.data;
                    
                    let totalBrightness = 0;
                    let pixelCount = 0;
                    
                    // Sample pixels (every 4th pixel for speed)
                    for (let i = 0; i < data.length; i += 16) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];
                        
                        // Calculate perceived brightness (human eye is more sensitive to green)
                        const brightness = (0.299 * r + 0.587 * g + 0.114 * b);
                        totalBrightness += brightness;
                        pixelCount++;
                    }
                    
                    const avgBrightness = totalBrightness / pixelCount;
                    // Returns true if image is "light" (brightness > 127)
                    callback(avgBrightness > 127);
                } catch (e) {
                    console.log('Could not analyze image brightness:', e);
                    callback(false); // Default to dark background assumption
                }
            };
            
            img.onerror = function() {
                callback(false); // Default to dark background assumption
            };
            
            img.src = imageUrl;
        }

        function setOverlayTheme(isLightBackground) {
            const calendar = document.getElementById('screensaver-mini-calendar');
            const metadata = document.getElementById('screensaver-metadata');
            const header = document.getElementById('main-header');
            const mailNotif = document.getElementById('mail-notification');
            
            if (isLightBackground) {
                // Light background = use dark overlay text
                calendar?.classList.remove('overlay-light');
                calendar?.classList.add('overlay-dark');
                metadata?.classList.remove('overlay-light');
                metadata?.classList.add('overlay-dark');
                header?.classList.remove('overlay-light');
                header?.classList.add('overlay-dark');
                mailNotif?.classList.remove('overlay-light');
                mailNotif?.classList.add('overlay-dark');
            } else {
                // Dark background = use light overlay text
                calendar?.classList.remove('overlay-dark');
                calendar?.classList.add('overlay-light');
                metadata?.classList.remove('overlay-dark');
                metadata?.classList.add('overlay-light');
                header?.classList.remove('overlay-dark');
                header?.classList.add('overlay-light');
                mailNotif?.classList.remove('overlay-dark');
                mailNotif?.classList.add('overlay-light');
            }
        }

        function resetOverlayThemes() {
            // Reset all overlay elements to their default state when screensaver ends
            const calendar = document.getElementById('screensaver-mini-calendar');
            const metadata = document.getElementById('screensaver-metadata');
            const header = document.getElementById('main-header');
            const mailNotif = document.getElementById('mail-notification');

            // Remove all overlay classes
            [calendar, metadata, header, mailNotif].forEach(el => {
                el?.classList.remove('overlay-light', 'overlay-dark');
            });

            // Reset mail notification to default light theme (for normal dashboard)
            mailNotif?.classList.add('overlay-light');
        }

        // Mini Calendar for Screensaver
        function updateMiniCalendar() {
            const now = new Date();
            const year = now.getFullYear();
            const month = now.getMonth();
            const today = now.getDate();

            const months = ['January', 'February', 'March', 'April', 'May', 'June',
                           'July', 'August', 'September', 'October', 'November', 'December'];

            // Update header
            document.getElementById('mini-cal-month').textContent = months[month];
            document.getElementById('mini-cal-year').textContent = year;

            // Get first day of month and number of days
            const firstDay = new Date(year, month, 1).getDay();
            const daysInMonth = new Date(year, month + 1, 0).getDate();

            // Build calendar grid
            const grid = document.getElementById('mini-cal-grid');

            // Clear existing days (keep headers)
            const headers = Array.from(grid.children).slice(0, 7);
            grid.innerHTML = '';
            headers.forEach(h => grid.appendChild(h));

            // Add empty cells for days before first of month
            for (let i = 0; i < firstDay; i++) {
                const empty = document.createElement('div');
                empty.className = 'cal-day w-10 h-10';
                grid.appendChild(empty);
            }

            // Add days
            for (let day = 1; day <= daysInMonth; day++) {
                const dayEl = document.createElement('div');
                dayEl.className = 'cal-day w-10 h-10 flex items-center justify-center text-lg font-medium';

                if (day === today) {
                    dayEl.className += ' cal-today';
                } else {
                    dayEl.className += ' opacity-90 hover:opacity-100';
                }

                dayEl.textContent = day;
                grid.appendChild(dayEl);
            }
        }

        // Screensaver Controller
        class ScreensaverController {
            constructor(options = {}) {
                this.overlay = document.getElementById('screensaverOverlay');
                this.bg1 = document.getElementById('screensaver-bg-1');
                this.bg2 = document.getElementById('screensaver-bg-2');
                this.loadingEl = document.getElementById('screensaver-loading');
                this.metadataEl = document.getElementById('screensaver-metadata');
                this.dateEl = document.getElementById('screensaver-date');
                this.locationEl = document.getElementById('screensaver-location');

                this.isActive = false;
                this.currentBg = 1;
                this.slideTimer = null;
                this.photoQueue = null;
                this.provider = null;
                this.slideInterval = options.slideInterval || 10000;
                this.kenBurnsEnabled = options.kenBurnsEnabled !== false;
                this.showMetadata = options.showMetadata !== false;

                this.kenBurnsEffects = ['kenburns-zoom-in', 'kenburns-zoom-out', 'kenburns-pan-left', 'kenburns-pan-right'];
            }

            async start() {
                if (this.isActive) {
                    console.log('Screensaver already active, skipping start');
                    return;
                }

                console.log('Starting screensaver...');
                this.isActive = true;

                // Notify MQTT bridge of state change
                if (mqttBridge) mqttBridge.notifyStateChange();

                // Show overlay and loading
                this.overlay.classList.remove('hidden');
                this.loadingEl.classList.remove('hidden');

                // Add screensaver-active class to body for header styling
                document.body.classList.add('screensaver-active');

                // Update mini calendar
                updateMiniCalendar();

                // Initialize provider if needed (or reinitialize if config changed)
                if (!this.provider) {
                    console.log('Initializing photo provider...');
                    await this.initializeProvider();
                }

                // Initialize photo queue
                if (this.provider) {
                    console.log('Provider ready, initializing photo queue...');
                    this.photoQueue = new PhotoQueue(this.provider);
                    
                    try {
                        const hasPhotos = await this.photoQueue.initialize();
                        console.log('Photo queue initialized, hasPhotos:', hasPhotos);

                        if (hasPhotos) {
                            this.loadingEl.classList.add('hidden');
                            this.showNextPhoto();
                            this.startSlideshow();
                        } else {
                            console.log('No photos available for screensaver');
                            this.loadingEl.querySelector('span').textContent = 'No photos available. Configure photo source in settings.';
                        }
                    } catch (e) {
                        console.error('Error initializing photo queue:', e);
                        this.loadingEl.querySelector('span').textContent = 'Error loading photos. Check settings.';
                    }
                } else {
                    console.log('No provider configured for screensaver');
                    this.loadingEl.querySelector('span').textContent = 'No photo source configured. Check settings.';
                }
            }

            async initializeProvider() {
                const config = screensaverSettings.providerConfig || {};

                switch (screensaverSettings.providerType) {
                    case 'local':
                        this.provider = new LocalFolderProvider(config);
                        break;
                    case 'synology':
                        this.provider = new SynologyPhotosProvider(config);
                        break;
                    default:
                        this.provider = null;
                }

                if (this.provider) {
                    await this.provider.authenticate();
                }
            }

            startSlideshow() {
                this.stopSlideshow();
                this.slideTimer = setInterval(() => {
                    this.showNextPhoto();
                }, this.slideInterval);
            }

            stopSlideshow() {
                if (this.slideTimer) {
                    clearInterval(this.slideTimer);
                    this.slideTimer = null;
                }
            }

            showNextPhoto() {
                const photo = this.photoQueue?.next();
                if (!photo) return;

                this.displayPhoto(photo);
            }

            previousPhoto() {
                const photo = this.photoQueue?.previous();
                if (!photo) return;

                this.displayPhoto(photo);
                // Reset the timer
                this.startSlideshow();
            }

            nextPhoto() {
                this.showNextPhoto();
                // Reset the timer
                this.startSlideshow();
            }

            displayPhoto(photo) {
                const url = this.photoQueue.getUrl(photo);
                if (!url) return;

                const activeBg = this.currentBg === 1 ? this.bg1 : this.bg2;
                const inactiveBg = this.currentBg === 1 ? this.bg2 : this.bg1;

                // Preload image before transitioning for smooth crossfade
                const img = new Image();
                img.onload = () => {
                    // Remove old Ken Burns classes
                    this.kenBurnsEffects.forEach(cls => {
                        inactiveBg.classList.remove(cls);
                    });

                    // Set new image on inactive layer (now fully loaded)
                    inactiveBg.style.backgroundImage = `url(${url})`;

                    // Add Ken Burns effect
                    if (this.kenBurnsEnabled) {
                        const effect = this.kenBurnsEffects[Math.floor(Math.random() * this.kenBurnsEffects.length)];
                        inactiveBg.classList.add(effect);
                    }

                    // Bring new image to front and fade it in over the old one
                    inactiveBg.style.zIndex = '2';
                    activeBg.style.zIndex = '1';
                    inactiveBg.style.opacity = '1';
                    
                    // After transition completes, hide old image and reset z-index
                    setTimeout(() => {
                        activeBg.style.opacity = '0';
                    }, 1600); // Slightly after the 1.5s CSS transition

                    this.currentBg = this.currentBg === 1 ? 2 : 1;

                    // Update metadata
                    this.updateMetadata(photo);

                    // Analyze image brightness and adjust overlay contrast
                    analyzeImageBrightness(url, (isLight) => {
                        setOverlayTheme(isLight);
                    });
                };
                img.onerror = () => {
                    console.error('Failed to load photo:', url);
                    // Skip to next photo on error
                    this.showNextPhoto();
                };
                img.src = url;
            }

            updateMetadata(photo) {
                if (!this.showMetadata || !screensaverSettings.showMetadata) {
                    this.metadataEl.classList.add('hidden');
                    return;
                }

                this.metadataEl.classList.remove('hidden');

                // Display date
                if (photo.time) {
                    this.dateEl.textContent = photo.time.toLocaleDateString('en-US', {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    });
                } else {
                    this.dateEl.textContent = photo.filename || '';
                }

                // Display location if available
                const gps = photo.additional?.gps;
                if (gps && gps.latitude && gps.longitude) {
                    this.locationEl.textContent = `${gps.latitude.toFixed(4)}, ${gps.longitude.toFixed(4)}`;
                } else {
                    this.locationEl.textContent = '';
                }
            }

            wake(reason = 'user') {
                if (!this.isActive) return;

                console.log(`Waking screensaver (reason: ${reason})`);

                this.isActive = false;
                this.stopSlideshow();

                // Hide overlay
                this.overlay.classList.add('hidden');

                // Remove screensaver-active class from body
                document.body.classList.remove('screensaver-active');

                // Reset overlay themes to default (remove contrast classes)
                resetOverlayThemes();

                // Reset backgrounds
                this.bg1.style.backgroundImage = '';
                this.bg2.style.backgroundImage = '';
                this.bg1.style.opacity = '1';
                this.bg2.style.opacity = '0';
                this.kenBurnsEffects.forEach(cls => {
                    this.bg1.classList.remove(cls);
                    this.bg2.classList.remove(cls);
                });

                // Notify MQTT bridge of state change
                if (mqttBridge) mqttBridge.notifyStateChange();
            }
        }

        // Settings Modal Functions
        function openScreensaverSettings() {
            // Wake screensaver if active
            if (screensaverController?.isActive) {
                screensaverController.wake('settings');
            }

            // Populate current values
            document.getElementById('ss-enabled').checked = screensaverSettings.enabled;
            document.getElementById('ss-idle-timeout').value = screensaverSettings.idleTimeout / 60000;
            document.getElementById('ss-idle-value').textContent = (screensaverSettings.idleTimeout / 60000) + ' minute' + (screensaverSettings.idleTimeout / 60000 === 1 ? '' : 's');
            document.getElementById('ss-slide-interval').value = screensaverSettings.slideInterval / 1000;
            document.getElementById('ss-slide-value').textContent = (screensaverSettings.slideInterval / 1000) + ' seconds';
            document.getElementById('ss-kenburns').checked = screensaverSettings.kenBurnsEnabled;
            document.getElementById('ss-metadata').checked = screensaverSettings.showMetadata;
            document.getElementById('ss-provider').value = screensaverSettings.providerType;
            document.getElementById('ss-local-path').value = screensaverSettings.providerConfig?.folderPath || '';
            document.getElementById('ss-synology-share').value = screensaverSettings.providerConfig?.shareLink || '';
            document.getElementById('ss-hourly-chime').checked = screensaverSettings.hourlyChimeEnabled;
            document.getElementById('ss-hourly-callout').checked = screensaverSettings.hourlyChimeCallout;
            document.getElementById('ss-chime-start').value = screensaverSettings.hourlyChimeStart;
            document.getElementById('ss-chime-end').value = screensaverSettings.hourlyChimeEnd;

            toggleProviderConfig(screensaverSettings.providerType);

            // Update MQTT status when opening settings
            updateMQTTStatus();

            document.getElementById('screensaverSettingsModal').classList.remove('hidden');
        }

        function closeScreensaverSettings() {
            document.getElementById('screensaverSettingsModal').classList.add('hidden');
        }

        async function testSynologyConnection() {
            const statusEl = document.getElementById('ss-connection-status');
            statusEl.classList.remove('hidden');
            statusEl.className = 'text-sm text-yellow-400';
            statusEl.textContent = 'Testing connection...';

            updateSynologyConfig();

            const provider = new SynologyPhotosProvider(screensaverSettings.providerConfig);
            const isAuth = await provider.authenticate();

            if (!isAuth) {
                statusEl.className = 'text-sm text-red-400';
                statusEl.textContent = 'Invalid share link. Please check the URL format.';
                return;
            }

            try {
                const photos = await provider.getPhotos();
                if (photos.length > 0) {
                    statusEl.className = 'text-sm text-green-400';
                    statusEl.textContent = `Success! Found ${photos.length} photos.`;
                } else {
                    statusEl.className = 'text-sm text-yellow-400';
                    statusEl.textContent = 'Connected but no photos found in album.';
                }
            } catch (e) {
                statusEl.className = 'text-sm text-red-400';
                statusEl.textContent = 'Connection failed. Check if the share link is correct and the server is accessible.';
            }
        }

        function previewScreensaver() {
            updateSynologyConfig();
            closeScreensaverSettings();

            // Reset provider to use new config
            if (screensaverController) {
                screensaverController.provider = null;
            }

            // Force start screensaver
            if (screensaverController) {
                screensaverController.slideInterval = screensaverSettings.slideInterval;
                screensaverController.kenBurnsEnabled = screensaverSettings.kenBurnsEnabled;
                screensaverController.showMetadata = screensaverSettings.showMetadata;
                screensaverController.start();
            }
        }

        // Initialize Screensaver System
        function initScreensaver() {
            loadScreensaverSettings();

            screensaverController = new ScreensaverController({
                slideInterval: screensaverSettings.slideInterval,
                kenBurnsEnabled: screensaverSettings.kenBurnsEnabled,
                showMetadata: screensaverSettings.showMetadata
            });

            idleDetector = new IdleDetector({
                timeout: screensaverSettings.idleTimeout,
                onIdle: () => {
                    if (screensaverSettings.enabled) {
                        screensaverController.start();
                    }
                },
                onActive: () => {
                    screensaverController.wake('user');
                }
            });

            if (screensaverSettings.enabled) {
                idleDetector.start();
            }

            console.log('Screensaver system initialized');
        }

        // ==================== END SCREENSAVER SYSTEM ====================

        // ==================== MQTT BRIDGE SYSTEM ====================

        class MQTTBridge {
            constructor() {
                this.ws = null;
                this.connected = false;
                this.reconnectAttempts = 0;
                this.maxReconnectAttempts = 10;
                this.reconnectDelay = 2000;
                this.wsPort = 8766; // Must match WS_PORT in config.py
            }

            connect() {
                try {
                    this.ws = new WebSocket(`ws://localhost:${this.wsPort}`);

                    this.ws.onopen = () => {
                        console.log('MQTT Bridge: Connected to WebSocket server');
                        this.connected = true;
                        this.reconnectAttempts = 0;
                        // Send initial state
                        this.sendState();
                    };

                    this.ws.onclose = () => {
                        console.log('MQTT Bridge: Disconnected');
                        this.connected = false;
                        this.scheduleReconnect();
                    };

                    this.ws.onerror = (error) => {
                        console.log('MQTT Bridge: WebSocket error (server may not be running with MQTT enabled)');
                    };

                    this.ws.onmessage = (event) => {
                        this.handleMessage(event.data);
                    };
                } catch (e) {
                    console.log('MQTT Bridge: Failed to connect:', e.message);
                    this.scheduleReconnect();
                }
            }

            scheduleReconnect() {
                if (this.reconnectAttempts < this.maxReconnectAttempts) {
                    this.reconnectAttempts++;
                    const delay = this.reconnectDelay * Math.min(this.reconnectAttempts, 5);
                    console.log(`MQTT Bridge: Reconnecting in ${delay/1000}s (attempt ${this.reconnectAttempts})`);
                    setTimeout(() => this.connect(), delay);
                } else {
                    console.log('MQTT Bridge: Max reconnect attempts reached, giving up');
                }
            }

            handleMessage(data) {
                try {
                    const cmd = JSON.parse(data);

                    // Check server version on every message
                    if (cmd.version) {
                        checkServerVersion(cmd.version);
                    }

                    // Handle screenshot request
                    if (cmd.type === 'screenshot_request') {
                        this.takeScreenshot();
                        return;
                    }

                    const command = cmd.command;
                    console.log('MQTT Bridge: Received command:', command);

                    switch (command) {
                        case 'wake':
                            // Exit screensaver
                            if (screensaverController?.isActive) {
                                screensaverController.wake('mqtt');
                            }
                            break;

                        case 'speak':
                            // Text-to-speech with optional alarm
                            this.handleSpeak(cmd);
                            break;

                        case 'reload':
                            // Refresh the dashboard
                            location.reload();
                            break;

                        case 'screensaver':
                            // Toggle screensaver
                            if (cmd.enabled) {
                                if (screensaverController && !screensaverController.isActive) {
                                    screensaverController.start();
                                }
                            } else {
                                if (screensaverController?.isActive) {
                                    screensaverController.wake('mqtt');
                                }
                            }
                            this.sendState();
                            break;

                        case 'navigate':
                            // Switch tab
                            const tab = cmd.tab;
                            if (['calendar', 'todos', 'controls'].includes(tab)) {
                                setActiveTab(tab);
                                // Wake screensaver if active
                                if (screensaverController?.isActive) {
                                    screensaverController.wake('mqtt');
                                }
                                this.sendState();
                            }
                            break;

                        case 'volume':
                            // Set volume
                            const volume = Math.max(0, Math.min(100, cmd.value || 70));
                            setAlarmVolume(volume);
                            // Update slider if exists
                            const slider = document.getElementById('alarm-volume');
                            if (slider) slider.value = volume;
                            this.sendState();
                            break;

                        case 'show_camera':
                            // Show camera feed (e.g., doorbell camera)
                            if (cameraViewer && cmd.entity_id) {
                                cameraViewer.show({
                                    entity_id: cmd.entity_id,
                                    title: cmd.title || 'Camera',
                                    duration: cmd.duration || 30,
                                    sound: cmd.sound !== false // default true
                                });
                            }
                            break;

                        case 'hide_camera':
                            // Hide camera overlay
                            if (cameraViewer) {
                                cameraViewer.hide();
                            }
                            break;

                        default:
                            console.log('MQTT Bridge: Unknown command:', command);
                    }

                    // Handle HA real-time events (from HA WebSocket subscription)
                    if (cmd.type === 'ha_event') {
                        this.handleHAEvent(cmd);
                    }
                } catch (e) {
                    console.error('MQTT Bridge: Error handling message:', e);
                }
            }

            handleHAEvent(event) {
                // Check server version on every event
                if (event.version) {
                    checkServerVersion(event.version);
                }

                const category = event.category;
                const eventType = event.event_type;
                const entityId = event.entity_id;
                const data = event.data || {};

                console.log(`HA Event: ${category} - ${entityId}`);

                switch (category) {
                    case 'notification':
                        // Get the specific notification ID from the event
                        const serviceData = data.service_data || {};
                        const eventNotifId = serviceData.notification_id;
                        const eventTitle = serviceData.title || 'Notification';
                        const eventMessage = serviceData.message || '';
                        
                        console.log('HA Event: Notification -', data.service, eventNotifId, eventTitle);
                        
                        // If this is a create event with data, announce it directly
                        // Use timestamp in key so same notification_id can be announced again if recreated
                        if (data.service === 'create' && eventNotifId) {
                            // Key includes current minute to allow re-announcement after a minute
                            const timeKey = Math.floor(Date.now() / 60000); // Changes every minute
                            const key = `notif|${eventNotifId}|${timeKey}`;
                            if (!wasAnnounced(key)) {
                                markAsAnnounced(key);
                                const fullText = eventMessage ? `${eventTitle}: ${eventMessage}` : eventTitle;
                                console.log('Announcing notification:', fullText.substring(0, 50));
                                announceNewItem('notification', fullText, eventMessage);
                            } else {
                                console.log('Notification already announced this minute:', eventNotifId);
                            }
                        }
                        
                        // Refresh the notifications list (but don't announce again)
                        loadMailNotifications();
                        break;

                    case 'mail':
                        // Refresh mail notifications and announce
                        console.log('HA Event: Mail changed, refreshing...');
                        loadMailNotifications().then(() => {
                            // Check for unannounced mail
                            const mailItems = allNotifications.filter(n => n.category === 'mail');
                            for (const mailItem of mailItems) {
                                const key = `notif|mail|${mailItem.id || mailItem.label}`;
                                if (!wasAnnounced(key)) {
                                    markAsAnnounced(key);
                                    announceNewItem('mail', `${mailItem.count} ${mailItem.label}`);
                                    break;
                                }
                            }
                        });
                        break;

                    case 'calendar':
                        // Refresh calendar events (no announcement - too many false positives from HA polling)
                        console.log('HA Event: Calendar changed, refreshing...');
                        loadCalendarEvents().then(() => renderCalendar());
                        break;

                    case 'todo':
                        // Refresh todos
                        console.log('HA Event: Todo changed, refreshing...');
                        loadTodos();
                        break;

                    case 'weather':
                        // Refresh weather
                        console.log('HA Event: Weather changed, refreshing...');
                        loadWeather();
                        break;

                    case 'sensor':
                        // Handle door/motion sensors
                        const newState = data.new_state;
                        if (newState && newState.state === 'on') {
                            if (entityId.includes('doorbell')) {
                                console.log('HA Event: Doorbell pressed!');
                                // Could trigger camera popup here
                            } else if (entityId.includes('motion')) {
                                console.log('HA Event: Motion detected:', entityId);
                            } else if (entityId.includes('door')) {
                                console.log('HA Event: Door opened:', entityId);
                            }
                        }
                        break;

                    case 'control':
                        // Update controls page if visible
                        console.log('HA Event: Control changed:', entityId);
                        if (typeof updateControlEntity === 'function') {
                            updateControlEntity(entityId, data.new_state);
                        }
                        break;

                    case 'prayer':
                        // Refresh prayer times
                        console.log('HA Event: Prayer time changed');
                        loadWeather(); // Prayer times are loaded with weather
                        break;
                }
            }

            handleSpeak(cmd) {
                const message = cmd.message || '';
                const playAlarm = cmd.alarm === true;
                const volume = cmd.volume;

                // Set volume if specified
                if (typeof volume === 'number') {
                    setAlarmVolume(Math.max(0, Math.min(100, volume)));
                }

                // Wake screensaver first
                if (screensaverController?.isActive) {
                    screensaverController.wake('mqtt');
                }

                // Play alarm sound if requested
                if (playAlarm) {
                    this.playMQTTAlarm();
                    // Speak after alarm sound (delay to let alarm play)
                    if (message) {
                        setTimeout(() => speakText(message), 1500);
                    }
                } else if (message) {
                    speakText(message);
                }
            }

            playMQTTAlarm() {
                // Play a short attention-getting sound
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const now = audioContext.currentTime;

                    const playTone = (freq, startTime, duration, vol = 0.4) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.linearRampToValueAtTime(vol * alarmVolume, startTime + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                        osc.start(startTime);
                        osc.stop(startTime + duration);
                    };

                    // Attention-getting two-tone alert
                    playTone(880, now, 0.15);        // A5
                    playTone(1100, now + 0.15, 0.15); // ~C#6
                    playTone(880, now + 0.3, 0.15);   // A5
                    playTone(1100, now + 0.45, 0.3);  // ~C#6 (longer)

                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                } catch (e) {
                    console.error('MQTT Bridge: Error playing alarm:', e);
                }
            }

            async takeScreenshot() {
                console.log('MQTT Bridge: Taking screenshot...');
                try {
                    // Use html2canvas to capture the page
                    const canvas = await html2canvas(document.body, {
                        scale: 1,
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: null,
                        logging: false
                    });
                    
                    // Convert to base64 PNG
                    const imageData = canvas.toDataURL('image/png');
                    console.log('MQTT Bridge: Screenshot captured, size:', imageData.length);
                    
                    // Send to server via WebSocket
                    if (this.ws && this.connected) {
                        this.ws.send(JSON.stringify({
                            type: 'screenshot_data',
                            image: imageData
                        }));
                        console.log('MQTT Bridge: Screenshot sent to server');
                    }
                } catch (e) {
                    console.error('MQTT Bridge: Error taking screenshot:', e);
                }
            }

            sendState() {
                if (!this.connected || !this.ws) return;

                const state = {
                    screensaver_active: screensaverController?.isActive || false,
                    camera_active: cameraViewer?.isActive || false,
                    current_tab: activeTab || 'calendar',
                    volume: Math.round(alarmVolume * 100)
                };

                try {
                    this.ws.send(JSON.stringify({
                        type: 'state_update',
                        state: state
                    }));
                } catch (e) {
                    console.error('MQTT Bridge: Error sending state:', e);
                }
            }

            // Call this when state changes to keep HA in sync
            notifyStateChange() {
                this.sendState();
            }
        }

        // Global MQTT bridge instance
        let mqttBridge = null;

        function initMQTTBridge() {
            mqttBridge = new MQTTBridge();
            mqttBridge.connect();
            console.log('MQTT Bridge initialized');

            // Update status display periodically
            setInterval(updateMQTTStatus, 5000);
        }

        // Update MQTT connection status in settings
        function updateMQTTStatus() {
            const wsStatusEl = document.getElementById('mqtt-ws-status');
            if (!wsStatusEl) return;

            const isConnected = mqttBridge?.connected || false;
            const dot = wsStatusEl.querySelector('span:first-child');
            const text = wsStatusEl.querySelector('span:last-child');

            if (isConnected) {
                dot.className = 'w-2 h-2 rounded-full bg-emerald-500';
                text.className = 'text-emerald-400 text-sm';
                text.textContent = 'Connected';
            } else {
                dot.className = 'w-2 h-2 rounded-full bg-red-500';
                text.className = 'text-red-400 text-sm';
                text.textContent = 'Disconnected';
            }

            // Broker status is unknown from frontend (would need server endpoint)
            const brokerStatusEl = document.getElementById('mqtt-broker-status');
            if (brokerStatusEl && isConnected) {
                const brokerDot = brokerStatusEl.querySelector('span:first-child');
                const brokerText = brokerStatusEl.querySelector('span:last-child');
                brokerDot.className = 'w-2 h-2 rounded-full bg-emerald-500';
                brokerText.className = 'text-emerald-400 text-sm';
                brokerText.textContent = 'Connected via server';
            }
        }

        // Test MQTT commands from settings
        function testMQTTCommand(command) {
            const statusEl = document.getElementById('mqtt-test-status');

            if (!mqttBridge?.connected) {
                statusEl.textContent = 'WebSocket not connected. Is the server running with MQTT enabled?';
                statusEl.className = 'text-sm text-center py-2 rounded bg-red-900/50 text-red-400';
                statusEl.classList.remove('hidden');
                setTimeout(() => statusEl.classList.add('hidden'), 3000);
                return;
            }

            switch (command) {
                case 'wake':
                    if (screensaverController?.isActive) {
                        screensaverController.wake('test');
                        showTestStatus('Screensaver dismissed', 'success');
                    } else {
                        showTestStatus('Screensaver not active', 'info');
                    }
                    break;

                case 'screensaver':
                    if (!screensaverController?.isActive) {
                        screensaverController?.start();
                        showTestStatus('Screensaver started', 'success');
                    } else {
                        showTestStatus('Screensaver already active', 'info');
                    }
                    break;

                case 'speak':
                    speakText('This is a test message from the Skylight Dashboard.');
                    showTestStatus('TTS message sent', 'success');
                    break;

                case 'doorbell':
                    // Simulate doorbell camera (use a test entity or just show the overlay)
                    if (cameraViewer) {
                        cameraViewer.playDoorbellSound();
                        showTestStatus('Doorbell sound played', 'success');
                    }
                    break;
            }
        }

        function showTestStatus(message, type) {
            const statusEl = document.getElementById('mqtt-test-status');
            statusEl.textContent = message;

            if (type === 'success') {
                statusEl.className = 'text-sm text-center py-2 rounded bg-emerald-900/50 text-emerald-400';
            } else if (type === 'error') {
                statusEl.className = 'text-sm text-center py-2 rounded bg-red-900/50 text-red-400';
            } else {
                statusEl.className = 'text-sm text-center py-2 rounded bg-slate-700 text-slate-300';
            }

            statusEl.classList.remove('hidden');
            setTimeout(() => statusEl.classList.add('hidden'), 3000);
        }

        // ==================== END MQTT BRIDGE SYSTEM ====================

        // ==================== CAMERA VIEWER SYSTEM ====================

        class CameraViewer {
            constructor() {
                this.overlay = document.getElementById('cameraOverlay');
                this.titleEl = document.getElementById('camera-title').querySelector('span');
                this.streamEl = document.getElementById('camera-stream');
                this.loadingEl = document.getElementById('camera-loading');
                this.errorEl = document.getElementById('camera-error');
                this.countdownEl = document.getElementById('camera-seconds');
                this.countdownContainer = document.getElementById('camera-countdown');

                this.isActive = false;
                this.countdownTimer = null;
                this.refreshTimer = null;
                this.remainingSeconds = 0;
                this.currentEntityId = null;
            }

            show(options = {}) {
                const {
                    entity_id,
                    title = 'Camera',
                    duration = 30,
                    sound = true
                } = options;

                if (!entity_id) {
                    console.error('CameraViewer: No entity_id provided');
                    return;
                }

                console.log(`CameraViewer: Showing camera ${entity_id} for ${duration}s`);

                // Wake screensaver if active
                if (screensaverController?.isActive) {
                    screensaverController.wake('camera');
                }

                // Play doorbell sound if requested
                if (sound) {
                    this.playDoorbellSound();
                }

                this.currentEntityId = entity_id;
                this.isActive = true;

                // Update title
                this.titleEl.textContent = title;

                // Show overlay and loading state
                this.overlay.classList.remove('hidden');
                this.loadingEl.classList.remove('hidden');
                this.streamEl.classList.add('hidden');
                this.errorEl.classList.add('hidden');

                // Start loading the camera stream
                this.loadCameraStream(entity_id);

                // Start countdown
                this.startCountdown(duration);

                // Notify MQTT bridge
                if (mqttBridge) mqttBridge.notifyStateChange();
            }

            hide() {
                console.log('CameraViewer: Hiding camera');

                this.isActive = false;
                this.currentEntityId = null;

                // Stop timers
                if (this.countdownTimer) {
                    clearInterval(this.countdownTimer);
                    this.countdownTimer = null;
                }
                if (this.refreshTimer) {
                    clearInterval(this.refreshTimer);
                    this.refreshTimer = null;
                }

                // Hide overlay
                this.overlay.classList.add('hidden');

                // Clear stream
                this.streamEl.src = '';

                // Notify MQTT bridge
                if (mqttBridge) mqttBridge.notifyStateChange();
            }

            async loadCameraStream(entity_id) {
                try {
                    // Use Home Assistant's camera proxy for the stream
                    // This works with MJPEG streams and provides periodic snapshots
                    const streamUrl = `/api/camera_proxy_stream/${entity_id}`;

                    // Set up error handling
                    this.streamEl.onerror = () => {
                        console.log('CameraViewer: Stream error, trying snapshot mode');
                        this.loadCameraSnapshot(entity_id);
                    };

                    this.streamEl.onload = () => {
                        this.loadingEl.classList.add('hidden');
                        this.streamEl.classList.remove('hidden');
                    };

                    // Try loading the stream
                    this.streamEl.src = streamUrl;

                    // Set a timeout for loading
                    setTimeout(() => {
                        if (this.loadingEl.classList.contains('hidden') === false && this.isActive) {
                            // Still loading after 5 seconds, try snapshot mode
                            console.log('CameraViewer: Stream timeout, trying snapshot mode');
                            this.loadCameraSnapshot(entity_id);
                        }
                    }, 5000);

                } catch (e) {
                    console.error('CameraViewer: Error loading stream:', e);
                    this.showError();
                }
            }

            async loadCameraSnapshot(entity_id) {
                try {
                    // Use snapshot endpoint instead
                    const snapshotUrl = `/api/camera_proxy/${entity_id}?time=${Date.now()}`;

                    this.streamEl.onerror = () => {
                        console.error('CameraViewer: Snapshot error');
                        this.showError();
                    };

                    this.streamEl.onload = () => {
                        this.loadingEl.classList.add('hidden');
                        this.streamEl.classList.remove('hidden');
                    };

                    this.streamEl.src = snapshotUrl;

                    // Refresh snapshot every 2 seconds for pseudo-live view
                    if (this.refreshTimer) clearInterval(this.refreshTimer);
                    this.refreshTimer = setInterval(() => {
                        if (this.isActive) {
                            this.streamEl.src = `/api/camera_proxy/${entity_id}?time=${Date.now()}`;
                        }
                    }, 2000);

                } catch (e) {
                    console.error('CameraViewer: Error loading snapshot:', e);
                    this.showError();
                }
            }

            showError() {
                this.loadingEl.classList.add('hidden');
                this.streamEl.classList.add('hidden');
                this.errorEl.classList.remove('hidden');
            }

            startCountdown(seconds) {
                this.remainingSeconds = seconds;
                this.countdownEl.textContent = seconds;
                this.countdownContainer.classList.remove('hidden');

                if (this.countdownTimer) clearInterval(this.countdownTimer);

                this.countdownTimer = setInterval(() => {
                    this.remainingSeconds--;
                    this.countdownEl.textContent = this.remainingSeconds;

                    if (this.remainingSeconds <= 0) {
                        this.hide();
                    }
                }, 1000);
            }

            resetCountdown(seconds = 30) {
                this.remainingSeconds = seconds;
                this.countdownEl.textContent = seconds;
            }

            playDoorbellSound() {
                try {
                    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    const now = audioContext.currentTime;

                    const playTone = (freq, startTime, duration, vol = 0.4) => {
                        const osc = audioContext.createOscillator();
                        const gain = audioContext.createGain();
                        osc.connect(gain);
                        gain.connect(audioContext.destination);
                        osc.frequency.value = freq;
                        osc.type = 'sine';
                        gain.gain.setValueAtTime(0, startTime);
                        gain.gain.linearRampToValueAtTime(vol * alarmVolume, startTime + 0.02);
                        gain.gain.exponentialRampToValueAtTime(0.01, startTime + duration);
                        osc.start(startTime);
                        osc.stop(startTime + duration);
                    };

                    // Classic doorbell "ding-dong" pattern
                    playTone(932, now, 0.4, 0.5);        // Bb5 (ding)
                    playTone(698, now + 0.4, 0.6, 0.5);  // F5 (dong)

                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                } catch (e) {
                    console.error('CameraViewer: Error playing doorbell sound:', e);
                }
            }

            toggleFullscreen() {
                if (!document.fullscreenElement) {
                    this.overlay.requestFullscreen().catch(e => {
                        console.log('CameraViewer: Fullscreen not supported');
                    });
                } else {
                    document.exitFullscreen();
                }
            }

            // Extend duration (useful when interacting)
            extend(additionalSeconds = 30) {
                this.remainingSeconds += additionalSeconds;
                this.countdownEl.textContent = this.remainingSeconds;
            }
        }

        // Global camera viewer instance
        let cameraViewer = null;

        function initCameraViewer() {
            cameraViewer = new CameraViewer();
            console.log('Camera viewer initialized');
        }

        // ==================== END CAMERA VIEWER SYSTEM ====================

        // ==================== HOURLY CHIME SYSTEM ====================

        let lastChimeHour = -1;

        // Play hourly chime sound
        function playHourlyChime() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();

                const playTone = (freq, startTime, duration, volume = 0.3) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';

                    // Soft bell-like envelope
                    gainNode.gain.setValueAtTime(0, startTime);
                    gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.02);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, startTime + duration);

                    oscillator.start(startTime);
                    oscillator.stop(startTime + duration);
                };

                const now = audioContext.currentTime;

                // Westminster-style chime (simplified)
                playTone(659.25, now, 0.5, 0.25);        // E5
                playTone(523.25, now + 0.5, 0.5, 0.25);  // C5
                playTone(587.33, now + 1.0, 0.5, 0.25);  // D5
                playTone(392.00, now + 1.5, 1.0, 0.3);   // G4 (longer)

                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }

                console.log('Hourly chime played');
            } catch (e) {
                console.error('Error playing hourly chime:', e);
            }
        }

        // Announce the time via TTS
        function announceTime() {
            const now = new Date();
            let hour = now.getHours();
            const ampm = hour >= 12 ? 'PM' : 'AM';
            hour = hour % 12 || 12;

            const timeText = `It's ${hour} o'clock ${ampm}`;
            speakText(timeText);
            console.log('Time announced:', timeText);
        }

        // Test the hourly chime
        function testHourlyChime() {
            playHourlyChime();
            if (screensaverSettings.hourlyChimeCallout) {
                setTimeout(announceTime, 2500);
            }
        }

        // Check if it's time to play the hourly chime
        function checkHourlyChime() {
            if (!screensaverSettings.hourlyChimeEnabled) return;

            const now = new Date();
            const currentHour = now.getHours();
            const currentMinute = now.getMinutes();

            // Only chime at the top of the hour (within first minute)
            if (currentMinute !== 0) return;

            // Don't repeat chime for the same hour
            if (currentHour === lastChimeHour) return;

            // Check if within allowed hours
            if (currentHour < screensaverSettings.hourlyChimeStart ||
                currentHour >= screensaverSettings.hourlyChimeEnd) {
                return;
            }

            lastChimeHour = currentHour;
            playHourlyChime();

            // Announce time after chime if enabled
            if (screensaverSettings.hourlyChimeCallout) {
                setTimeout(announceTime, 2500);
            }
        }

        // ==================== END HOURLY CHIME SYSTEM ====================

        // Start
        init();
    </script>
</body>
</html>
